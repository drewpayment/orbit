// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: idp/kafka/v1/kafka.proto

package kafkav1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ProviderType int32

const (
	ProviderType_PROVIDER_TYPE_UNSPECIFIED     ProviderType = 0
	ProviderType_PROVIDER_TYPE_APACHE_KAFKA    ProviderType = 1
	ProviderType_PROVIDER_TYPE_CONFLUENT_CLOUD ProviderType = 2
	ProviderType_PROVIDER_TYPE_AWS_MSK         ProviderType = 3
	ProviderType_PROVIDER_TYPE_REDPANDA        ProviderType = 4
	ProviderType_PROVIDER_TYPE_AIVEN           ProviderType = 5
)

// Enum value maps for ProviderType.
var (
	ProviderType_name = map[int32]string{
		0: "PROVIDER_TYPE_UNSPECIFIED",
		1: "PROVIDER_TYPE_APACHE_KAFKA",
		2: "PROVIDER_TYPE_CONFLUENT_CLOUD",
		3: "PROVIDER_TYPE_AWS_MSK",
		4: "PROVIDER_TYPE_REDPANDA",
		5: "PROVIDER_TYPE_AIVEN",
	}
	ProviderType_value = map[string]int32{
		"PROVIDER_TYPE_UNSPECIFIED":     0,
		"PROVIDER_TYPE_APACHE_KAFKA":    1,
		"PROVIDER_TYPE_CONFLUENT_CLOUD": 2,
		"PROVIDER_TYPE_AWS_MSK":         3,
		"PROVIDER_TYPE_REDPANDA":        4,
		"PROVIDER_TYPE_AIVEN":           5,
	}
)

func (x ProviderType) Enum() *ProviderType {
	p := new(ProviderType)
	*p = x
	return p
}

func (x ProviderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProviderType) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[0].Descriptor()
}

func (ProviderType) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[0]
}

func (x ProviderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProviderType.Descriptor instead.
func (ProviderType) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{0}
}

type ClusterValidationStatus int32

const (
	ClusterValidationStatus_CLUSTER_VALIDATION_STATUS_UNSPECIFIED ClusterValidationStatus = 0
	ClusterValidationStatus_CLUSTER_VALIDATION_STATUS_PENDING     ClusterValidationStatus = 1
	ClusterValidationStatus_CLUSTER_VALIDATION_STATUS_VALID       ClusterValidationStatus = 2
	ClusterValidationStatus_CLUSTER_VALIDATION_STATUS_INVALID     ClusterValidationStatus = 3
)

// Enum value maps for ClusterValidationStatus.
var (
	ClusterValidationStatus_name = map[int32]string{
		0: "CLUSTER_VALIDATION_STATUS_UNSPECIFIED",
		1: "CLUSTER_VALIDATION_STATUS_PENDING",
		2: "CLUSTER_VALIDATION_STATUS_VALID",
		3: "CLUSTER_VALIDATION_STATUS_INVALID",
	}
	ClusterValidationStatus_value = map[string]int32{
		"CLUSTER_VALIDATION_STATUS_UNSPECIFIED": 0,
		"CLUSTER_VALIDATION_STATUS_PENDING":     1,
		"CLUSTER_VALIDATION_STATUS_VALID":       2,
		"CLUSTER_VALIDATION_STATUS_INVALID":     3,
	}
)

func (x ClusterValidationStatus) Enum() *ClusterValidationStatus {
	p := new(ClusterValidationStatus)
	*p = x
	return p
}

func (x ClusterValidationStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterValidationStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[1].Descriptor()
}

func (ClusterValidationStatus) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[1]
}

func (x ClusterValidationStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterValidationStatus.Descriptor instead.
func (ClusterValidationStatus) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{1}
}

type TopicStatus int32

const (
	TopicStatus_TOPIC_STATUS_UNSPECIFIED      TopicStatus = 0
	TopicStatus_TOPIC_STATUS_PENDING_APPROVAL TopicStatus = 1
	TopicStatus_TOPIC_STATUS_PROVISIONING     TopicStatus = 2
	TopicStatus_TOPIC_STATUS_ACTIVE           TopicStatus = 3
	TopicStatus_TOPIC_STATUS_FAILED           TopicStatus = 4
	TopicStatus_TOPIC_STATUS_DELETING         TopicStatus = 5
)

// Enum value maps for TopicStatus.
var (
	TopicStatus_name = map[int32]string{
		0: "TOPIC_STATUS_UNSPECIFIED",
		1: "TOPIC_STATUS_PENDING_APPROVAL",
		2: "TOPIC_STATUS_PROVISIONING",
		3: "TOPIC_STATUS_ACTIVE",
		4: "TOPIC_STATUS_FAILED",
		5: "TOPIC_STATUS_DELETING",
	}
	TopicStatus_value = map[string]int32{
		"TOPIC_STATUS_UNSPECIFIED":      0,
		"TOPIC_STATUS_PENDING_APPROVAL": 1,
		"TOPIC_STATUS_PROVISIONING":     2,
		"TOPIC_STATUS_ACTIVE":           3,
		"TOPIC_STATUS_FAILED":           4,
		"TOPIC_STATUS_DELETING":         5,
	}
)

func (x TopicStatus) Enum() *TopicStatus {
	p := new(TopicStatus)
	*p = x
	return p
}

func (x TopicStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TopicStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[2].Descriptor()
}

func (TopicStatus) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[2]
}

func (x TopicStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TopicStatus.Descriptor instead.
func (TopicStatus) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{2}
}

type SchemaFormat int32

const (
	SchemaFormat_SCHEMA_FORMAT_UNSPECIFIED SchemaFormat = 0
	SchemaFormat_SCHEMA_FORMAT_AVRO        SchemaFormat = 1
	SchemaFormat_SCHEMA_FORMAT_PROTOBUF    SchemaFormat = 2
	SchemaFormat_SCHEMA_FORMAT_JSON        SchemaFormat = 3
)

// Enum value maps for SchemaFormat.
var (
	SchemaFormat_name = map[int32]string{
		0: "SCHEMA_FORMAT_UNSPECIFIED",
		1: "SCHEMA_FORMAT_AVRO",
		2: "SCHEMA_FORMAT_PROTOBUF",
		3: "SCHEMA_FORMAT_JSON",
	}
	SchemaFormat_value = map[string]int32{
		"SCHEMA_FORMAT_UNSPECIFIED": 0,
		"SCHEMA_FORMAT_AVRO":        1,
		"SCHEMA_FORMAT_PROTOBUF":    2,
		"SCHEMA_FORMAT_JSON":        3,
	}
)

func (x SchemaFormat) Enum() *SchemaFormat {
	p := new(SchemaFormat)
	*p = x
	return p
}

func (x SchemaFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SchemaFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[3].Descriptor()
}

func (SchemaFormat) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[3]
}

func (x SchemaFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SchemaFormat.Descriptor instead.
func (SchemaFormat) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{3}
}

type SchemaCompatibility int32

const (
	SchemaCompatibility_SCHEMA_COMPATIBILITY_UNSPECIFIED SchemaCompatibility = 0
	SchemaCompatibility_SCHEMA_COMPATIBILITY_BACKWARD    SchemaCompatibility = 1
	SchemaCompatibility_SCHEMA_COMPATIBILITY_FORWARD     SchemaCompatibility = 2
	SchemaCompatibility_SCHEMA_COMPATIBILITY_FULL        SchemaCompatibility = 3
	SchemaCompatibility_SCHEMA_COMPATIBILITY_NONE        SchemaCompatibility = 4
)

// Enum value maps for SchemaCompatibility.
var (
	SchemaCompatibility_name = map[int32]string{
		0: "SCHEMA_COMPATIBILITY_UNSPECIFIED",
		1: "SCHEMA_COMPATIBILITY_BACKWARD",
		2: "SCHEMA_COMPATIBILITY_FORWARD",
		3: "SCHEMA_COMPATIBILITY_FULL",
		4: "SCHEMA_COMPATIBILITY_NONE",
	}
	SchemaCompatibility_value = map[string]int32{
		"SCHEMA_COMPATIBILITY_UNSPECIFIED": 0,
		"SCHEMA_COMPATIBILITY_BACKWARD":    1,
		"SCHEMA_COMPATIBILITY_FORWARD":     2,
		"SCHEMA_COMPATIBILITY_FULL":        3,
		"SCHEMA_COMPATIBILITY_NONE":        4,
	}
)

func (x SchemaCompatibility) Enum() *SchemaCompatibility {
	p := new(SchemaCompatibility)
	*p = x
	return p
}

func (x SchemaCompatibility) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SchemaCompatibility) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[4].Descriptor()
}

func (SchemaCompatibility) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[4]
}

func (x SchemaCompatibility) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SchemaCompatibility.Descriptor instead.
func (SchemaCompatibility) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{4}
}

type ServiceAccountType int32

const (
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED       ServiceAccountType = 0
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_PRODUCER          ServiceAccountType = 1
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_CONSUMER          ServiceAccountType = 2
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_PRODUCER_CONSUMER ServiceAccountType = 3
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_ADMIN             ServiceAccountType = 4
)

// Enum value maps for ServiceAccountType.
var (
	ServiceAccountType_name = map[int32]string{
		0: "SERVICE_ACCOUNT_TYPE_UNSPECIFIED",
		1: "SERVICE_ACCOUNT_TYPE_PRODUCER",
		2: "SERVICE_ACCOUNT_TYPE_CONSUMER",
		3: "SERVICE_ACCOUNT_TYPE_PRODUCER_CONSUMER",
		4: "SERVICE_ACCOUNT_TYPE_ADMIN",
	}
	ServiceAccountType_value = map[string]int32{
		"SERVICE_ACCOUNT_TYPE_UNSPECIFIED":       0,
		"SERVICE_ACCOUNT_TYPE_PRODUCER":          1,
		"SERVICE_ACCOUNT_TYPE_CONSUMER":          2,
		"SERVICE_ACCOUNT_TYPE_PRODUCER_CONSUMER": 3,
		"SERVICE_ACCOUNT_TYPE_ADMIN":             4,
	}
)

func (x ServiceAccountType) Enum() *ServiceAccountType {
	p := new(ServiceAccountType)
	*p = x
	return p
}

func (x ServiceAccountType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ServiceAccountType) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[5].Descriptor()
}

func (ServiceAccountType) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[5]
}

func (x ServiceAccountType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ServiceAccountType.Descriptor instead.
func (ServiceAccountType) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{5}
}

type ShareStatus int32

const (
	ShareStatus_SHARE_STATUS_UNSPECIFIED     ShareStatus = 0
	ShareStatus_SHARE_STATUS_PENDING_REQUEST ShareStatus = 1
	ShareStatus_SHARE_STATUS_APPROVED        ShareStatus = 2
	ShareStatus_SHARE_STATUS_REJECTED        ShareStatus = 3
	ShareStatus_SHARE_STATUS_REVOKED         ShareStatus = 4
)

// Enum value maps for ShareStatus.
var (
	ShareStatus_name = map[int32]string{
		0: "SHARE_STATUS_UNSPECIFIED",
		1: "SHARE_STATUS_PENDING_REQUEST",
		2: "SHARE_STATUS_APPROVED",
		3: "SHARE_STATUS_REJECTED",
		4: "SHARE_STATUS_REVOKED",
	}
	ShareStatus_value = map[string]int32{
		"SHARE_STATUS_UNSPECIFIED":     0,
		"SHARE_STATUS_PENDING_REQUEST": 1,
		"SHARE_STATUS_APPROVED":        2,
		"SHARE_STATUS_REJECTED":        3,
		"SHARE_STATUS_REVOKED":         4,
	}
)

func (x ShareStatus) Enum() *ShareStatus {
	p := new(ShareStatus)
	*p = x
	return p
}

func (x ShareStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ShareStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[6].Descriptor()
}

func (ShareStatus) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[6]
}

func (x ShareStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ShareStatus.Descriptor instead.
func (ShareStatus) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{6}
}

type SharePermission int32

const (
	SharePermission_SHARE_PERMISSION_UNSPECIFIED SharePermission = 0
	SharePermission_SHARE_PERMISSION_READ        SharePermission = 1
	SharePermission_SHARE_PERMISSION_WRITE       SharePermission = 2
	SharePermission_SHARE_PERMISSION_READ_WRITE  SharePermission = 3
)

// Enum value maps for SharePermission.
var (
	SharePermission_name = map[int32]string{
		0: "SHARE_PERMISSION_UNSPECIFIED",
		1: "SHARE_PERMISSION_READ",
		2: "SHARE_PERMISSION_WRITE",
		3: "SHARE_PERMISSION_READ_WRITE",
	}
	SharePermission_value = map[string]int32{
		"SHARE_PERMISSION_UNSPECIFIED": 0,
		"SHARE_PERMISSION_READ":        1,
		"SHARE_PERMISSION_WRITE":       2,
		"SHARE_PERMISSION_READ_WRITE":  3,
	}
)

func (x SharePermission) Enum() *SharePermission {
	p := new(SharePermission)
	*p = x
	return p
}

func (x SharePermission) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SharePermission) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[7].Descriptor()
}

func (SharePermission) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[7]
}

func (x SharePermission) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SharePermission.Descriptor instead.
func (SharePermission) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{7}
}

type TopicVisibility int32

const (
	TopicVisibility_TOPIC_VISIBILITY_UNSPECIFIED  TopicVisibility = 0
	TopicVisibility_TOPIC_VISIBILITY_PRIVATE      TopicVisibility = 1
	TopicVisibility_TOPIC_VISIBILITY_DISCOVERABLE TopicVisibility = 2
	TopicVisibility_TOPIC_VISIBILITY_PUBLIC       TopicVisibility = 3
)

// Enum value maps for TopicVisibility.
var (
	TopicVisibility_name = map[int32]string{
		0: "TOPIC_VISIBILITY_UNSPECIFIED",
		1: "TOPIC_VISIBILITY_PRIVATE",
		2: "TOPIC_VISIBILITY_DISCOVERABLE",
		3: "TOPIC_VISIBILITY_PUBLIC",
	}
	TopicVisibility_value = map[string]int32{
		"TOPIC_VISIBILITY_UNSPECIFIED":  0,
		"TOPIC_VISIBILITY_PRIVATE":      1,
		"TOPIC_VISIBILITY_DISCOVERABLE": 2,
		"TOPIC_VISIBILITY_PUBLIC":       3,
	}
)

func (x TopicVisibility) Enum() *TopicVisibility {
	p := new(TopicVisibility)
	*p = x
	return p
}

func (x TopicVisibility) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TopicVisibility) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[8].Descriptor()
}

func (TopicVisibility) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[8]
}

func (x TopicVisibility) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TopicVisibility.Descriptor instead.
func (TopicVisibility) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{8}
}

type PolicyScope int32

const (
	PolicyScope_POLICY_SCOPE_UNSPECIFIED PolicyScope = 0
	PolicyScope_POLICY_SCOPE_PLATFORM    PolicyScope = 1
	PolicyScope_POLICY_SCOPE_WORKSPACE   PolicyScope = 2
)

// Enum value maps for PolicyScope.
var (
	PolicyScope_name = map[int32]string{
		0: "POLICY_SCOPE_UNSPECIFIED",
		1: "POLICY_SCOPE_PLATFORM",
		2: "POLICY_SCOPE_WORKSPACE",
	}
	PolicyScope_value = map[string]int32{
		"POLICY_SCOPE_UNSPECIFIED": 0,
		"POLICY_SCOPE_PLATFORM":    1,
		"POLICY_SCOPE_WORKSPACE":   2,
	}
)

func (x PolicyScope) Enum() *PolicyScope {
	p := new(PolicyScope)
	*p = x
	return p
}

func (x PolicyScope) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyScope) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[9].Descriptor()
}

func (PolicyScope) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[9]
}

func (x PolicyScope) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyScope.Descriptor instead.
func (PolicyScope) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{9}
}

type SharePolicyScope int32

const (
	SharePolicyScope_SHARE_POLICY_SCOPE_UNSPECIFIED    SharePolicyScope = 0
	SharePolicyScope_SHARE_POLICY_SCOPE_ALL_TOPICS     SharePolicyScope = 1
	SharePolicyScope_SHARE_POLICY_SCOPE_TOPIC_PATTERN  SharePolicyScope = 2
	SharePolicyScope_SHARE_POLICY_SCOPE_SPECIFIC_TOPIC SharePolicyScope = 3
)

// Enum value maps for SharePolicyScope.
var (
	SharePolicyScope_name = map[int32]string{
		0: "SHARE_POLICY_SCOPE_UNSPECIFIED",
		1: "SHARE_POLICY_SCOPE_ALL_TOPICS",
		2: "SHARE_POLICY_SCOPE_TOPIC_PATTERN",
		3: "SHARE_POLICY_SCOPE_SPECIFIC_TOPIC",
	}
	SharePolicyScope_value = map[string]int32{
		"SHARE_POLICY_SCOPE_UNSPECIFIED":    0,
		"SHARE_POLICY_SCOPE_ALL_TOPICS":     1,
		"SHARE_POLICY_SCOPE_TOPIC_PATTERN":  2,
		"SHARE_POLICY_SCOPE_SPECIFIC_TOPIC": 3,
	}
)

func (x SharePolicyScope) Enum() *SharePolicyScope {
	p := new(SharePolicyScope)
	*p = x
	return p
}

func (x SharePolicyScope) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SharePolicyScope) Descriptor() protoreflect.EnumDescriptor {
	return file_idp_kafka_v1_kafka_proto_enumTypes[10].Descriptor()
}

func (SharePolicyScope) Type() protoreflect.EnumType {
	return &file_idp_kafka_v1_kafka_proto_enumTypes[10]
}

func (x SharePolicyScope) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SharePolicyScope.Descriptor instead.
func (SharePolicyScope) EnumDescriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{10}
}

type KafkaProvider struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DisplayName          string                 `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	AdapterType          string                 `protobuf:"bytes,4,opt,name=adapter_type,json=adapterType,proto3" json:"adapter_type,omitempty"`
	RequiredConfigFields []string               `protobuf:"bytes,5,rep,name=required_config_fields,json=requiredConfigFields,proto3" json:"required_config_fields,omitempty"`
	Capabilities         *ProviderCapabilities  `protobuf:"bytes,6,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	DocumentationUrl     string                 `protobuf:"bytes,7,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	IconUrl              string                 `protobuf:"bytes,8,opt,name=icon_url,json=iconUrl,proto3" json:"icon_url,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *KafkaProvider) Reset() {
	*x = KafkaProvider{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaProvider) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaProvider) ProtoMessage() {}

func (x *KafkaProvider) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaProvider.ProtoReflect.Descriptor instead.
func (*KafkaProvider) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{0}
}

func (x *KafkaProvider) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaProvider) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KafkaProvider) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *KafkaProvider) GetAdapterType() string {
	if x != nil {
		return x.AdapterType
	}
	return ""
}

func (x *KafkaProvider) GetRequiredConfigFields() []string {
	if x != nil {
		return x.RequiredConfigFields
	}
	return nil
}

func (x *KafkaProvider) GetCapabilities() *ProviderCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *KafkaProvider) GetDocumentationUrl() string {
	if x != nil {
		return x.DocumentationUrl
	}
	return ""
}

func (x *KafkaProvider) GetIconUrl() string {
	if x != nil {
		return x.IconUrl
	}
	return ""
}

type ProviderCapabilities struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	SchemaRegistry bool                   `protobuf:"varint,1,opt,name=schema_registry,json=schemaRegistry,proto3" json:"schema_registry,omitempty"`
	Transactions   bool                   `protobuf:"varint,2,opt,name=transactions,proto3" json:"transactions,omitempty"`
	QuotasApi      bool                   `protobuf:"varint,3,opt,name=quotas_api,json=quotasApi,proto3" json:"quotas_api,omitempty"`
	MetricsApi     bool                   `protobuf:"varint,4,opt,name=metrics_api,json=metricsApi,proto3" json:"metrics_api,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProviderCapabilities) Reset() {
	*x = ProviderCapabilities{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProviderCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProviderCapabilities) ProtoMessage() {}

func (x *ProviderCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProviderCapabilities.ProtoReflect.Descriptor instead.
func (*ProviderCapabilities) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{1}
}

func (x *ProviderCapabilities) GetSchemaRegistry() bool {
	if x != nil {
		return x.SchemaRegistry
	}
	return false
}

func (x *ProviderCapabilities) GetTransactions() bool {
	if x != nil {
		return x.Transactions
	}
	return false
}

func (x *ProviderCapabilities) GetQuotasApi() bool {
	if x != nil {
		return x.QuotasApi
	}
	return false
}

func (x *ProviderCapabilities) GetMetricsApi() bool {
	if x != nil {
		return x.MetricsApi
	}
	return false
}

type KafkaCluster struct {
	state            protoimpl.MessageState  `protogen:"open.v1"`
	Id               string                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string                  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ProviderId       string                  `protobuf:"bytes,3,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	ConnectionConfig map[string]string       `protobuf:"bytes,4,rep,name=connection_config,json=connectionConfig,proto3" json:"connection_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ValidationStatus ClusterValidationStatus `protobuf:"varint,5,opt,name=validation_status,json=validationStatus,proto3,enum=idp.kafka.v1.ClusterValidationStatus" json:"validation_status,omitempty"`
	LastValidatedAt  *timestamppb.Timestamp  `protobuf:"bytes,6,opt,name=last_validated_at,json=lastValidatedAt,proto3" json:"last_validated_at,omitempty"`
	CreatedAt        *timestamppb.Timestamp  `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt        *timestamppb.Timestamp  `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *KafkaCluster) Reset() {
	*x = KafkaCluster{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaCluster) ProtoMessage() {}

func (x *KafkaCluster) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaCluster.ProtoReflect.Descriptor instead.
func (*KafkaCluster) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{2}
}

func (x *KafkaCluster) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaCluster) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KafkaCluster) GetProviderId() string {
	if x != nil {
		return x.ProviderId
	}
	return ""
}

func (x *KafkaCluster) GetConnectionConfig() map[string]string {
	if x != nil {
		return x.ConnectionConfig
	}
	return nil
}

func (x *KafkaCluster) GetValidationStatus() ClusterValidationStatus {
	if x != nil {
		return x.ValidationStatus
	}
	return ClusterValidationStatus_CLUSTER_VALIDATION_STATUS_UNSPECIFIED
}

func (x *KafkaCluster) GetLastValidatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastValidatedAt
	}
	return nil
}

func (x *KafkaCluster) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *KafkaCluster) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type KafkaEnvironmentMapping struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Environment   string                 `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment,omitempty"`
	ClusterId     string                 `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	RoutingRule   map[string]string      `protobuf:"bytes,4,rep,name=routing_rule,json=routingRule,proto3" json:"routing_rule,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Priority      int32                  `protobuf:"varint,5,opt,name=priority,proto3" json:"priority,omitempty"`
	IsDefault     bool                   `protobuf:"varint,6,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KafkaEnvironmentMapping) Reset() {
	*x = KafkaEnvironmentMapping{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaEnvironmentMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaEnvironmentMapping) ProtoMessage() {}

func (x *KafkaEnvironmentMapping) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaEnvironmentMapping.ProtoReflect.Descriptor instead.
func (*KafkaEnvironmentMapping) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{3}
}

func (x *KafkaEnvironmentMapping) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaEnvironmentMapping) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *KafkaEnvironmentMapping) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *KafkaEnvironmentMapping) GetRoutingRule() map[string]string {
	if x != nil {
		return x.RoutingRule
	}
	return nil
}

func (x *KafkaEnvironmentMapping) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *KafkaEnvironmentMapping) GetIsDefault() bool {
	if x != nil {
		return x.IsDefault
	}
	return false
}

type SchemaRegistry struct {
	state                 protoimpl.MessageState              `protogen:"open.v1"`
	Id                    string                              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Url                   string                              `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	SubjectNamingTemplate string                              `protobuf:"bytes,3,opt,name=subject_naming_template,json=subjectNamingTemplate,proto3" json:"subject_naming_template,omitempty"`
	DefaultCompatibility  SchemaCompatibility                 `protobuf:"varint,4,opt,name=default_compatibility,json=defaultCompatibility,proto3,enum=idp.kafka.v1.SchemaCompatibility" json:"default_compatibility,omitempty"`
	EnvironmentOverrides  []*EnvironmentCompatibilityOverride `protobuf:"bytes,5,rep,name=environment_overrides,json=environmentOverrides,proto3" json:"environment_overrides,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *SchemaRegistry) Reset() {
	*x = SchemaRegistry{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaRegistry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaRegistry) ProtoMessage() {}

func (x *SchemaRegistry) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaRegistry.ProtoReflect.Descriptor instead.
func (*SchemaRegistry) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{4}
}

func (x *SchemaRegistry) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SchemaRegistry) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *SchemaRegistry) GetSubjectNamingTemplate() string {
	if x != nil {
		return x.SubjectNamingTemplate
	}
	return ""
}

func (x *SchemaRegistry) GetDefaultCompatibility() SchemaCompatibility {
	if x != nil {
		return x.DefaultCompatibility
	}
	return SchemaCompatibility_SCHEMA_COMPATIBILITY_UNSPECIFIED
}

func (x *SchemaRegistry) GetEnvironmentOverrides() []*EnvironmentCompatibilityOverride {
	if x != nil {
		return x.EnvironmentOverrides
	}
	return nil
}

type EnvironmentCompatibilityOverride struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Environment   string                 `protobuf:"bytes,1,opt,name=environment,proto3" json:"environment,omitempty"`
	Compatibility SchemaCompatibility    `protobuf:"varint,2,opt,name=compatibility,proto3,enum=idp.kafka.v1.SchemaCompatibility" json:"compatibility,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnvironmentCompatibilityOverride) Reset() {
	*x = EnvironmentCompatibilityOverride{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnvironmentCompatibilityOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnvironmentCompatibilityOverride) ProtoMessage() {}

func (x *EnvironmentCompatibilityOverride) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnvironmentCompatibilityOverride.ProtoReflect.Descriptor instead.
func (*EnvironmentCompatibilityOverride) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{5}
}

func (x *EnvironmentCompatibilityOverride) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *EnvironmentCompatibilityOverride) GetCompatibility() SchemaCompatibility {
	if x != nil {
		return x.Compatibility
	}
	return SchemaCompatibility_SCHEMA_COMPATIBILITY_UNSPECIFIED
}

type KafkaTopic struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Id                string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	WorkspaceId       string                 `protobuf:"bytes,2,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Name              string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Environment       string                 `protobuf:"bytes,4,opt,name=environment,proto3" json:"environment,omitempty"`
	ClusterId         string                 `protobuf:"bytes,5,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Partitions        int32                  `protobuf:"varint,6,opt,name=partitions,proto3" json:"partitions,omitempty"`
	ReplicationFactor int32                  `protobuf:"varint,7,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	RetentionMs       int64                  `protobuf:"varint,8,opt,name=retention_ms,json=retentionMs,proto3" json:"retention_ms,omitempty"`
	CleanupPolicy     string                 `protobuf:"bytes,9,opt,name=cleanup_policy,json=cleanupPolicy,proto3" json:"cleanup_policy,omitempty"`
	Compression       string                 `protobuf:"bytes,10,opt,name=compression,proto3" json:"compression,omitempty"`
	Config            map[string]string      `protobuf:"bytes,11,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Status            TopicStatus            `protobuf:"varint,12,opt,name=status,proto3,enum=idp.kafka.v1.TopicStatus" json:"status,omitempty"`
	WorkflowId        string                 `protobuf:"bytes,13,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	ApprovalRequired  bool                   `protobuf:"varint,14,opt,name=approval_required,json=approvalRequired,proto3" json:"approval_required,omitempty"`
	ApprovedBy        string                 `protobuf:"bytes,15,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	ApprovedAt        *timestamppb.Timestamp `protobuf:"bytes,16,opt,name=approved_at,json=approvedAt,proto3" json:"approved_at,omitempty"`
	CreatedAt         *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt         *timestamppb.Timestamp `protobuf:"bytes,18,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Description       string                 `protobuf:"bytes,19,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *KafkaTopic) Reset() {
	*x = KafkaTopic{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaTopic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaTopic) ProtoMessage() {}

func (x *KafkaTopic) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaTopic.ProtoReflect.Descriptor instead.
func (*KafkaTopic) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{6}
}

func (x *KafkaTopic) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaTopic) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaTopic) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KafkaTopic) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *KafkaTopic) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *KafkaTopic) GetPartitions() int32 {
	if x != nil {
		return x.Partitions
	}
	return 0
}

func (x *KafkaTopic) GetReplicationFactor() int32 {
	if x != nil {
		return x.ReplicationFactor
	}
	return 0
}

func (x *KafkaTopic) GetRetentionMs() int64 {
	if x != nil {
		return x.RetentionMs
	}
	return 0
}

func (x *KafkaTopic) GetCleanupPolicy() string {
	if x != nil {
		return x.CleanupPolicy
	}
	return ""
}

func (x *KafkaTopic) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *KafkaTopic) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *KafkaTopic) GetStatus() TopicStatus {
	if x != nil {
		return x.Status
	}
	return TopicStatus_TOPIC_STATUS_UNSPECIFIED
}

func (x *KafkaTopic) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *KafkaTopic) GetApprovalRequired() bool {
	if x != nil {
		return x.ApprovalRequired
	}
	return false
}

func (x *KafkaTopic) GetApprovedBy() string {
	if x != nil {
		return x.ApprovedBy
	}
	return ""
}

func (x *KafkaTopic) GetApprovedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ApprovedAt
	}
	return nil
}

func (x *KafkaTopic) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *KafkaTopic) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *KafkaTopic) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type KafkaSchema struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	WorkspaceId   string                 `protobuf:"bytes,2,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	TopicId       string                 `protobuf:"bytes,3,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Type          string                 `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"` // "key" or "value"
	Subject       string                 `protobuf:"bytes,5,opt,name=subject,proto3" json:"subject,omitempty"`
	Format        SchemaFormat           `protobuf:"varint,6,opt,name=format,proto3,enum=idp.kafka.v1.SchemaFormat" json:"format,omitempty"`
	Content       string                 `protobuf:"bytes,7,opt,name=content,proto3" json:"content,omitempty"`
	Version       int32                  `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	SchemaId      int32                  `protobuf:"varint,9,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty"`
	Compatibility SchemaCompatibility    `protobuf:"varint,10,opt,name=compatibility,proto3,enum=idp.kafka.v1.SchemaCompatibility" json:"compatibility,omitempty"`
	Status        string                 `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KafkaSchema) Reset() {
	*x = KafkaSchema{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaSchema) ProtoMessage() {}

func (x *KafkaSchema) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaSchema.ProtoReflect.Descriptor instead.
func (*KafkaSchema) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{7}
}

func (x *KafkaSchema) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaSchema) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaSchema) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *KafkaSchema) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *KafkaSchema) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *KafkaSchema) GetFormat() SchemaFormat {
	if x != nil {
		return x.Format
	}
	return SchemaFormat_SCHEMA_FORMAT_UNSPECIFIED
}

func (x *KafkaSchema) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *KafkaSchema) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *KafkaSchema) GetSchemaId() int32 {
	if x != nil {
		return x.SchemaId
	}
	return 0
}

func (x *KafkaSchema) GetCompatibility() SchemaCompatibility {
	if x != nil {
		return x.Compatibility
	}
	return SchemaCompatibility_SCHEMA_COMPATIBILITY_UNSPECIFIED
}

func (x *KafkaSchema) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *KafkaSchema) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *KafkaSchema) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type KafkaServiceAccount struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	WorkspaceId   string                 `protobuf:"bytes,2,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Type          ServiceAccountType     `protobuf:"varint,4,opt,name=type,proto3,enum=idp.kafka.v1.ServiceAccountType" json:"type,omitempty"`
	Status        string                 `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	CreatedBy     string                 `protobuf:"bytes,6,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KafkaServiceAccount) Reset() {
	*x = KafkaServiceAccount{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaServiceAccount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaServiceAccount) ProtoMessage() {}

func (x *KafkaServiceAccount) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaServiceAccount.ProtoReflect.Descriptor instead.
func (*KafkaServiceAccount) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{8}
}

func (x *KafkaServiceAccount) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaServiceAccount) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaServiceAccount) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KafkaServiceAccount) GetType() ServiceAccountType {
	if x != nil {
		return x.Type
	}
	return ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED
}

func (x *KafkaServiceAccount) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *KafkaServiceAccount) GetCreatedBy() string {
	if x != nil {
		return x.CreatedBy
	}
	return ""
}

func (x *KafkaServiceAccount) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

type KafkaTopicShare struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Id                    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TopicId               string                 `protobuf:"bytes,2,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	SharedWithType        string                 `protobuf:"bytes,3,opt,name=shared_with_type,json=sharedWithType,proto3" json:"shared_with_type,omitempty"` // "workspace" or "user"
	SharedWithWorkspaceId string                 `protobuf:"bytes,4,opt,name=shared_with_workspace_id,json=sharedWithWorkspaceId,proto3" json:"shared_with_workspace_id,omitempty"`
	SharedWithUserId      string                 `protobuf:"bytes,5,opt,name=shared_with_user_id,json=sharedWithUserId,proto3" json:"shared_with_user_id,omitempty"`
	Permission            SharePermission        `protobuf:"varint,6,opt,name=permission,proto3,enum=idp.kafka.v1.SharePermission" json:"permission,omitempty"`
	Status                ShareStatus            `protobuf:"varint,7,opt,name=status,proto3,enum=idp.kafka.v1.ShareStatus" json:"status,omitempty"`
	RequestedBy           string                 `protobuf:"bytes,8,opt,name=requested_by,json=requestedBy,proto3" json:"requested_by,omitempty"`
	RequestedAt           *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	Justification         string                 `protobuf:"bytes,10,opt,name=justification,proto3" json:"justification,omitempty"`
	ApprovedBy            string                 `protobuf:"bytes,11,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	ApprovedAt            *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=approved_at,json=approvedAt,proto3" json:"approved_at,omitempty"`
	ExpiresAt             *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *KafkaTopicShare) Reset() {
	*x = KafkaTopicShare{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaTopicShare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaTopicShare) ProtoMessage() {}

func (x *KafkaTopicShare) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaTopicShare.ProtoReflect.Descriptor instead.
func (*KafkaTopicShare) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{9}
}

func (x *KafkaTopicShare) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaTopicShare) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *KafkaTopicShare) GetSharedWithType() string {
	if x != nil {
		return x.SharedWithType
	}
	return ""
}

func (x *KafkaTopicShare) GetSharedWithWorkspaceId() string {
	if x != nil {
		return x.SharedWithWorkspaceId
	}
	return ""
}

func (x *KafkaTopicShare) GetSharedWithUserId() string {
	if x != nil {
		return x.SharedWithUserId
	}
	return ""
}

func (x *KafkaTopicShare) GetPermission() SharePermission {
	if x != nil {
		return x.Permission
	}
	return SharePermission_SHARE_PERMISSION_UNSPECIFIED
}

func (x *KafkaTopicShare) GetStatus() ShareStatus {
	if x != nil {
		return x.Status
	}
	return ShareStatus_SHARE_STATUS_UNSPECIFIED
}

func (x *KafkaTopicShare) GetRequestedBy() string {
	if x != nil {
		return x.RequestedBy
	}
	return ""
}

func (x *KafkaTopicShare) GetRequestedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.RequestedAt
	}
	return nil
}

func (x *KafkaTopicShare) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

func (x *KafkaTopicShare) GetApprovedBy() string {
	if x != nil {
		return x.ApprovedBy
	}
	return ""
}

func (x *KafkaTopicShare) GetApprovedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ApprovedAt
	}
	return nil
}

func (x *KafkaTopicShare) GetExpiresAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiresAt
	}
	return nil
}

type KafkaTopicPolicy struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Id                  string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Scope               PolicyScope            `protobuf:"varint,2,opt,name=scope,proto3,enum=idp.kafka.v1.PolicyScope" json:"scope,omitempty"`
	WorkspaceId         string                 `protobuf:"bytes,3,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Environment         string                 `protobuf:"bytes,4,opt,name=environment,proto3" json:"environment,omitempty"`
	NamingPattern       string                 `protobuf:"bytes,5,opt,name=naming_pattern,json=namingPattern,proto3" json:"naming_pattern,omitempty"`
	AutoApprovePatterns []string               `protobuf:"bytes,6,rep,name=auto_approve_patterns,json=autoApprovePatterns,proto3" json:"auto_approve_patterns,omitempty"`
	PartitionLimits     *PartitionLimits       `protobuf:"bytes,7,opt,name=partition_limits,json=partitionLimits,proto3" json:"partition_limits,omitempty"`
	RetentionLimits     *RetentionLimits       `protobuf:"bytes,8,opt,name=retention_limits,json=retentionLimits,proto3" json:"retention_limits,omitempty"`
	RequireSchema       bool                   `protobuf:"varint,9,opt,name=require_schema,json=requireSchema,proto3" json:"require_schema,omitempty"`
	RequireApprovalFor  []string               `protobuf:"bytes,10,rep,name=require_approval_for,json=requireApprovalFor,proto3" json:"require_approval_for,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *KafkaTopicPolicy) Reset() {
	*x = KafkaTopicPolicy{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaTopicPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaTopicPolicy) ProtoMessage() {}

func (x *KafkaTopicPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaTopicPolicy.ProtoReflect.Descriptor instead.
func (*KafkaTopicPolicy) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{10}
}

func (x *KafkaTopicPolicy) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaTopicPolicy) GetScope() PolicyScope {
	if x != nil {
		return x.Scope
	}
	return PolicyScope_POLICY_SCOPE_UNSPECIFIED
}

func (x *KafkaTopicPolicy) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaTopicPolicy) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *KafkaTopicPolicy) GetNamingPattern() string {
	if x != nil {
		return x.NamingPattern
	}
	return ""
}

func (x *KafkaTopicPolicy) GetAutoApprovePatterns() []string {
	if x != nil {
		return x.AutoApprovePatterns
	}
	return nil
}

func (x *KafkaTopicPolicy) GetPartitionLimits() *PartitionLimits {
	if x != nil {
		return x.PartitionLimits
	}
	return nil
}

func (x *KafkaTopicPolicy) GetRetentionLimits() *RetentionLimits {
	if x != nil {
		return x.RetentionLimits
	}
	return nil
}

func (x *KafkaTopicPolicy) GetRequireSchema() bool {
	if x != nil {
		return x.RequireSchema
	}
	return false
}

func (x *KafkaTopicPolicy) GetRequireApprovalFor() []string {
	if x != nil {
		return x.RequireApprovalFor
	}
	return nil
}

type PartitionLimits struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           int32                  `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           int32                  `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionLimits) Reset() {
	*x = PartitionLimits{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionLimits) ProtoMessage() {}

func (x *PartitionLimits) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionLimits.ProtoReflect.Descriptor instead.
func (*PartitionLimits) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{11}
}

func (x *PartitionLimits) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *PartitionLimits) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

type RetentionLimits struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinMs         int64                  `protobuf:"varint,1,opt,name=min_ms,json=minMs,proto3" json:"min_ms,omitempty"`
	MaxMs         int64                  `protobuf:"varint,2,opt,name=max_ms,json=maxMs,proto3" json:"max_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetentionLimits) Reset() {
	*x = RetentionLimits{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetentionLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetentionLimits) ProtoMessage() {}

func (x *RetentionLimits) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetentionLimits.ProtoReflect.Descriptor instead.
func (*RetentionLimits) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{12}
}

func (x *RetentionLimits) GetMinMs() int64 {
	if x != nil {
		return x.MinMs
	}
	return 0
}

func (x *RetentionLimits) GetMaxMs() int64 {
	if x != nil {
		return x.MaxMs
	}
	return 0
}

type KafkaTopicSharePolicy struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	WorkspaceId          string                 `protobuf:"bytes,2,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Scope                SharePolicyScope       `protobuf:"varint,3,opt,name=scope,proto3,enum=idp.kafka.v1.SharePolicyScope" json:"scope,omitempty"`
	TopicPattern         string                 `protobuf:"bytes,4,opt,name=topic_pattern,json=topicPattern,proto3" json:"topic_pattern,omitempty"`
	TopicId              string                 `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Environment          string                 `protobuf:"bytes,6,opt,name=environment,proto3" json:"environment,omitempty"`
	Visibility           TopicVisibility        `protobuf:"varint,7,opt,name=visibility,proto3,enum=idp.kafka.v1.TopicVisibility" json:"visibility,omitempty"`
	AutoApprove          *AutoApproveConfig     `protobuf:"bytes,8,opt,name=auto_approve,json=autoApprove,proto3" json:"auto_approve,omitempty"`
	DefaultPermission    SharePermission        `protobuf:"varint,9,opt,name=default_permission,json=defaultPermission,proto3,enum=idp.kafka.v1.SharePermission" json:"default_permission,omitempty"`
	RequireJustification bool                   `protobuf:"varint,10,opt,name=require_justification,json=requireJustification,proto3" json:"require_justification,omitempty"`
	AccessTtlDays        int32                  `protobuf:"varint,11,opt,name=access_ttl_days,json=accessTtlDays,proto3" json:"access_ttl_days,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *KafkaTopicSharePolicy) Reset() {
	*x = KafkaTopicSharePolicy{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaTopicSharePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaTopicSharePolicy) ProtoMessage() {}

func (x *KafkaTopicSharePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaTopicSharePolicy.ProtoReflect.Descriptor instead.
func (*KafkaTopicSharePolicy) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{13}
}

func (x *KafkaTopicSharePolicy) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaTopicSharePolicy) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaTopicSharePolicy) GetScope() SharePolicyScope {
	if x != nil {
		return x.Scope
	}
	return SharePolicyScope_SHARE_POLICY_SCOPE_UNSPECIFIED
}

func (x *KafkaTopicSharePolicy) GetTopicPattern() string {
	if x != nil {
		return x.TopicPattern
	}
	return ""
}

func (x *KafkaTopicSharePolicy) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *KafkaTopicSharePolicy) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *KafkaTopicSharePolicy) GetVisibility() TopicVisibility {
	if x != nil {
		return x.Visibility
	}
	return TopicVisibility_TOPIC_VISIBILITY_UNSPECIFIED
}

func (x *KafkaTopicSharePolicy) GetAutoApprove() *AutoApproveConfig {
	if x != nil {
		return x.AutoApprove
	}
	return nil
}

func (x *KafkaTopicSharePolicy) GetDefaultPermission() SharePermission {
	if x != nil {
		return x.DefaultPermission
	}
	return SharePermission_SHARE_PERMISSION_UNSPECIFIED
}

func (x *KafkaTopicSharePolicy) GetRequireJustification() bool {
	if x != nil {
		return x.RequireJustification
	}
	return false
}

func (x *KafkaTopicSharePolicy) GetAccessTtlDays() int32 {
	if x != nil {
		return x.AccessTtlDays
	}
	return 0
}

type AutoApproveConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Environments       []string               `protobuf:"bytes,1,rep,name=environments,proto3" json:"environments,omitempty"`
	Permissions        []SharePermission      `protobuf:"varint,2,rep,packed,name=permissions,proto3,enum=idp.kafka.v1.SharePermission" json:"permissions,omitempty"`
	WorkspaceWhitelist []string               `protobuf:"bytes,3,rep,name=workspace_whitelist,json=workspaceWhitelist,proto3" json:"workspace_whitelist,omitempty"`
	SameTenantOnly     bool                   `protobuf:"varint,4,opt,name=same_tenant_only,json=sameTenantOnly,proto3" json:"same_tenant_only,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *AutoApproveConfig) Reset() {
	*x = AutoApproveConfig{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoApproveConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoApproveConfig) ProtoMessage() {}

func (x *AutoApproveConfig) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoApproveConfig.ProtoReflect.Descriptor instead.
func (*AutoApproveConfig) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{14}
}

func (x *AutoApproveConfig) GetEnvironments() []string {
	if x != nil {
		return x.Environments
	}
	return nil
}

func (x *AutoApproveConfig) GetPermissions() []SharePermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *AutoApproveConfig) GetWorkspaceWhitelist() []string {
	if x != nil {
		return x.WorkspaceWhitelist
	}
	return nil
}

func (x *AutoApproveConfig) GetSameTenantOnly() bool {
	if x != nil {
		return x.SameTenantOnly
	}
	return false
}

type KafkaUsageMetrics struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TopicId         string                 `protobuf:"bytes,2,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Period          string                 `protobuf:"bytes,3,opt,name=period,proto3" json:"period,omitempty"`
	PeriodType      string                 `protobuf:"bytes,4,opt,name=period_type,json=periodType,proto3" json:"period_type,omitempty"`
	BytesIn         int64                  `protobuf:"varint,5,opt,name=bytes_in,json=bytesIn,proto3" json:"bytes_in,omitempty"`
	BytesOut        int64                  `protobuf:"varint,6,opt,name=bytes_out,json=bytesOut,proto3" json:"bytes_out,omitempty"`
	MessageCountIn  int64                  `protobuf:"varint,7,opt,name=message_count_in,json=messageCountIn,proto3" json:"message_count_in,omitempty"`
	MessageCountOut int64                  `protobuf:"varint,8,opt,name=message_count_out,json=messageCountOut,proto3" json:"message_count_out,omitempty"`
	StorageBytes    int64                  `protobuf:"varint,9,opt,name=storage_bytes,json=storageBytes,proto3" json:"storage_bytes,omitempty"`
	PartitionCount  int32                  `protobuf:"varint,10,opt,name=partition_count,json=partitionCount,proto3" json:"partition_count,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *KafkaUsageMetrics) Reset() {
	*x = KafkaUsageMetrics{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaUsageMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaUsageMetrics) ProtoMessage() {}

func (x *KafkaUsageMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaUsageMetrics.ProtoReflect.Descriptor instead.
func (*KafkaUsageMetrics) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{15}
}

func (x *KafkaUsageMetrics) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaUsageMetrics) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *KafkaUsageMetrics) GetPeriod() string {
	if x != nil {
		return x.Period
	}
	return ""
}

func (x *KafkaUsageMetrics) GetPeriodType() string {
	if x != nil {
		return x.PeriodType
	}
	return ""
}

func (x *KafkaUsageMetrics) GetBytesIn() int64 {
	if x != nil {
		return x.BytesIn
	}
	return 0
}

func (x *KafkaUsageMetrics) GetBytesOut() int64 {
	if x != nil {
		return x.BytesOut
	}
	return 0
}

func (x *KafkaUsageMetrics) GetMessageCountIn() int64 {
	if x != nil {
		return x.MessageCountIn
	}
	return 0
}

func (x *KafkaUsageMetrics) GetMessageCountOut() int64 {
	if x != nil {
		return x.MessageCountOut
	}
	return 0
}

func (x *KafkaUsageMetrics) GetStorageBytes() int64 {
	if x != nil {
		return x.StorageBytes
	}
	return 0
}

func (x *KafkaUsageMetrics) GetPartitionCount() int32 {
	if x != nil {
		return x.PartitionCount
	}
	return 0
}

type KafkaConsumerGroup struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Id               string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupId          string                 `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	ClusterId        string                 `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	TopicIds         []string               `protobuf:"bytes,4,rep,name=topic_ids,json=topicIds,proto3" json:"topic_ids,omitempty"`
	ServiceAccountId string                 `protobuf:"bytes,5,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	WorkspaceId      string                 `protobuf:"bytes,6,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	CurrentLag       int64                  `protobuf:"varint,7,opt,name=current_lag,json=currentLag,proto3" json:"current_lag,omitempty"`
	LastSeen         *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	LastUpdated      *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *KafkaConsumerGroup) Reset() {
	*x = KafkaConsumerGroup{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaConsumerGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaConsumerGroup) ProtoMessage() {}

func (x *KafkaConsumerGroup) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaConsumerGroup.ProtoReflect.Descriptor instead.
func (*KafkaConsumerGroup) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{16}
}

func (x *KafkaConsumerGroup) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaConsumerGroup) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *KafkaConsumerGroup) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *KafkaConsumerGroup) GetTopicIds() []string {
	if x != nil {
		return x.TopicIds
	}
	return nil
}

func (x *KafkaConsumerGroup) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *KafkaConsumerGroup) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaConsumerGroup) GetCurrentLag() int64 {
	if x != nil {
		return x.CurrentLag
	}
	return 0
}

func (x *KafkaConsumerGroup) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

func (x *KafkaConsumerGroup) GetLastUpdated() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdated
	}
	return nil
}

type KafkaClientActivity struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Id               string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ClientId         string                 `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	ServiceAccountId string                 `protobuf:"bytes,3,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	WorkspaceId      string                 `protobuf:"bytes,4,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	TopicId          string                 `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Direction        string                 `protobuf:"bytes,6,opt,name=direction,proto3" json:"direction,omitempty"` // "produce" or "consume"
	ConsumerGroupId  string                 `protobuf:"bytes,7,opt,name=consumer_group_id,json=consumerGroupId,proto3" json:"consumer_group_id,omitempty"`
	BytesTransferred int64                  `protobuf:"varint,8,opt,name=bytes_transferred,json=bytesTransferred,proto3" json:"bytes_transferred,omitempty"`
	LastSeen         *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *KafkaClientActivity) Reset() {
	*x = KafkaClientActivity{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaClientActivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaClientActivity) ProtoMessage() {}

func (x *KafkaClientActivity) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaClientActivity.ProtoReflect.Descriptor instead.
func (*KafkaClientActivity) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{17}
}

func (x *KafkaClientActivity) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *KafkaClientActivity) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *KafkaClientActivity) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *KafkaClientActivity) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *KafkaClientActivity) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *KafkaClientActivity) GetDirection() string {
	if x != nil {
		return x.Direction
	}
	return ""
}

func (x *KafkaClientActivity) GetConsumerGroupId() string {
	if x != nil {
		return x.ConsumerGroupId
	}
	return ""
}

func (x *KafkaClientActivity) GetBytesTransferred() int64 {
	if x != nil {
		return x.BytesTransferred
	}
	return 0
}

func (x *KafkaClientActivity) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

// Cluster Management
type ListProvidersRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProvidersRequest) Reset() {
	*x = ListProvidersRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProvidersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProvidersRequest) ProtoMessage() {}

func (x *ListProvidersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProvidersRequest.ProtoReflect.Descriptor instead.
func (*ListProvidersRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{18}
}

type ListProvidersResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Providers     []*KafkaProvider       `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProvidersResponse) Reset() {
	*x = ListProvidersResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProvidersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProvidersResponse) ProtoMessage() {}

func (x *ListProvidersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProvidersResponse.ProtoReflect.Descriptor instead.
func (*ListProvidersResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{19}
}

func (x *ListProvidersResponse) GetProviders() []*KafkaProvider {
	if x != nil {
		return x.Providers
	}
	return nil
}

type RegisterClusterRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Name             string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ProviderId       string                 `protobuf:"bytes,2,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	ConnectionConfig map[string]string      `protobuf:"bytes,3,rep,name=connection_config,json=connectionConfig,proto3" json:"connection_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Credentials      map[string]string      `protobuf:"bytes,4,rep,name=credentials,proto3" json:"credentials,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RegisterClusterRequest) Reset() {
	*x = RegisterClusterRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterClusterRequest) ProtoMessage() {}

func (x *RegisterClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterClusterRequest.ProtoReflect.Descriptor instead.
func (*RegisterClusterRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{20}
}

func (x *RegisterClusterRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RegisterClusterRequest) GetProviderId() string {
	if x != nil {
		return x.ProviderId
	}
	return ""
}

func (x *RegisterClusterRequest) GetConnectionConfig() map[string]string {
	if x != nil {
		return x.ConnectionConfig
	}
	return nil
}

func (x *RegisterClusterRequest) GetCredentials() map[string]string {
	if x != nil {
		return x.Credentials
	}
	return nil
}

type RegisterClusterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cluster       *KafkaCluster          `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterClusterResponse) Reset() {
	*x = RegisterClusterResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterClusterResponse) ProtoMessage() {}

func (x *RegisterClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterClusterResponse.ProtoReflect.Descriptor instead.
func (*RegisterClusterResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{21}
}

func (x *RegisterClusterResponse) GetCluster() *KafkaCluster {
	if x != nil {
		return x.Cluster
	}
	return nil
}

func (x *RegisterClusterResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ValidateClusterRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClusterId     string                 `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateClusterRequest) Reset() {
	*x = ValidateClusterRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateClusterRequest) ProtoMessage() {}

func (x *ValidateClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateClusterRequest.ProtoReflect.Descriptor instead.
func (*ValidateClusterRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{22}
}

func (x *ValidateClusterRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

type ValidateClusterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Valid         bool                   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateClusterResponse) Reset() {
	*x = ValidateClusterResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateClusterResponse) ProtoMessage() {}

func (x *ValidateClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateClusterResponse.ProtoReflect.Descriptor instead.
func (*ValidateClusterResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{23}
}

func (x *ValidateClusterResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ValidateClusterResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListClustersRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClustersRequest) Reset() {
	*x = ListClustersRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClustersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClustersRequest) ProtoMessage() {}

func (x *ListClustersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClustersRequest.ProtoReflect.Descriptor instead.
func (*ListClustersRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{24}
}

type ListClustersResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Clusters      []*KafkaCluster        `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClustersResponse) Reset() {
	*x = ListClustersResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClustersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClustersResponse) ProtoMessage() {}

func (x *ListClustersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClustersResponse.ProtoReflect.Descriptor instead.
func (*ListClustersResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{25}
}

func (x *ListClustersResponse) GetClusters() []*KafkaCluster {
	if x != nil {
		return x.Clusters
	}
	return nil
}

type DeleteClusterRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClusterId     string                 `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteClusterRequest) Reset() {
	*x = DeleteClusterRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteClusterRequest) ProtoMessage() {}

func (x *DeleteClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteClusterRequest.ProtoReflect.Descriptor instead.
func (*DeleteClusterRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{26}
}

func (x *DeleteClusterRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

type DeleteClusterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteClusterResponse) Reset() {
	*x = DeleteClusterResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteClusterResponse) ProtoMessage() {}

func (x *DeleteClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteClusterResponse.ProtoReflect.Descriptor instead.
func (*DeleteClusterResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{27}
}

func (x *DeleteClusterResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DeleteClusterResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Environment Mapping
type CreateEnvironmentMappingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Environment   string                 `protobuf:"bytes,1,opt,name=environment,proto3" json:"environment,omitempty"`
	ClusterId     string                 `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	RoutingRule   map[string]string      `protobuf:"bytes,3,rep,name=routing_rule,json=routingRule,proto3" json:"routing_rule,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Priority      int32                  `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	IsDefault     bool                   `protobuf:"varint,5,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateEnvironmentMappingRequest) Reset() {
	*x = CreateEnvironmentMappingRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateEnvironmentMappingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateEnvironmentMappingRequest) ProtoMessage() {}

func (x *CreateEnvironmentMappingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateEnvironmentMappingRequest.ProtoReflect.Descriptor instead.
func (*CreateEnvironmentMappingRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{28}
}

func (x *CreateEnvironmentMappingRequest) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *CreateEnvironmentMappingRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *CreateEnvironmentMappingRequest) GetRoutingRule() map[string]string {
	if x != nil {
		return x.RoutingRule
	}
	return nil
}

func (x *CreateEnvironmentMappingRequest) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *CreateEnvironmentMappingRequest) GetIsDefault() bool {
	if x != nil {
		return x.IsDefault
	}
	return false
}

type CreateEnvironmentMappingResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Mapping       *KafkaEnvironmentMapping `protobuf:"bytes,1,opt,name=mapping,proto3" json:"mapping,omitempty"`
	Error         string                   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateEnvironmentMappingResponse) Reset() {
	*x = CreateEnvironmentMappingResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateEnvironmentMappingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateEnvironmentMappingResponse) ProtoMessage() {}

func (x *CreateEnvironmentMappingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateEnvironmentMappingResponse.ProtoReflect.Descriptor instead.
func (*CreateEnvironmentMappingResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{29}
}

func (x *CreateEnvironmentMappingResponse) GetMapping() *KafkaEnvironmentMapping {
	if x != nil {
		return x.Mapping
	}
	return nil
}

func (x *CreateEnvironmentMappingResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListEnvironmentMappingsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Environment   string                 `protobuf:"bytes,1,opt,name=environment,proto3" json:"environment,omitempty"` // optional filter
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListEnvironmentMappingsRequest) Reset() {
	*x = ListEnvironmentMappingsRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListEnvironmentMappingsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListEnvironmentMappingsRequest) ProtoMessage() {}

func (x *ListEnvironmentMappingsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListEnvironmentMappingsRequest.ProtoReflect.Descriptor instead.
func (*ListEnvironmentMappingsRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{30}
}

func (x *ListEnvironmentMappingsRequest) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

type ListEnvironmentMappingsResponse struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	Mappings      []*KafkaEnvironmentMapping `protobuf:"bytes,1,rep,name=mappings,proto3" json:"mappings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListEnvironmentMappingsResponse) Reset() {
	*x = ListEnvironmentMappingsResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListEnvironmentMappingsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListEnvironmentMappingsResponse) ProtoMessage() {}

func (x *ListEnvironmentMappingsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListEnvironmentMappingsResponse.ProtoReflect.Descriptor instead.
func (*ListEnvironmentMappingsResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{31}
}

func (x *ListEnvironmentMappingsResponse) GetMappings() []*KafkaEnvironmentMapping {
	if x != nil {
		return x.Mappings
	}
	return nil
}

type DeleteEnvironmentMappingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MappingId     string                 `protobuf:"bytes,1,opt,name=mapping_id,json=mappingId,proto3" json:"mapping_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteEnvironmentMappingRequest) Reset() {
	*x = DeleteEnvironmentMappingRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteEnvironmentMappingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteEnvironmentMappingRequest) ProtoMessage() {}

func (x *DeleteEnvironmentMappingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteEnvironmentMappingRequest.ProtoReflect.Descriptor instead.
func (*DeleteEnvironmentMappingRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{32}
}

func (x *DeleteEnvironmentMappingRequest) GetMappingId() string {
	if x != nil {
		return x.MappingId
	}
	return ""
}

type DeleteEnvironmentMappingResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteEnvironmentMappingResponse) Reset() {
	*x = DeleteEnvironmentMappingResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteEnvironmentMappingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteEnvironmentMappingResponse) ProtoMessage() {}

func (x *DeleteEnvironmentMappingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteEnvironmentMappingResponse.ProtoReflect.Descriptor instead.
func (*DeleteEnvironmentMappingResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{33}
}

func (x *DeleteEnvironmentMappingResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DeleteEnvironmentMappingResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Topic Management
type CreateTopicRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	WorkspaceId       string                 `protobuf:"bytes,1,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Name              string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Environment       string                 `protobuf:"bytes,3,opt,name=environment,proto3" json:"environment,omitempty"`
	Partitions        int32                  `protobuf:"varint,4,opt,name=partitions,proto3" json:"partitions,omitempty"`
	ReplicationFactor int32                  `protobuf:"varint,5,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	RetentionMs       int64                  `protobuf:"varint,6,opt,name=retention_ms,json=retentionMs,proto3" json:"retention_ms,omitempty"`
	CleanupPolicy     string                 `protobuf:"bytes,7,opt,name=cleanup_policy,json=cleanupPolicy,proto3" json:"cleanup_policy,omitempty"`
	Compression       string                 `protobuf:"bytes,8,opt,name=compression,proto3" json:"compression,omitempty"`
	Config            map[string]string      `protobuf:"bytes,9,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Description       string                 `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
	Schema            *KafkaSchema           `protobuf:"bytes,11,opt,name=schema,proto3" json:"schema,omitempty"` // optional schema to register
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CreateTopicRequest) Reset() {
	*x = CreateTopicRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicRequest) ProtoMessage() {}

func (x *CreateTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTopicRequest.ProtoReflect.Descriptor instead.
func (*CreateTopicRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{34}
}

func (x *CreateTopicRequest) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *CreateTopicRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateTopicRequest) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *CreateTopicRequest) GetPartitions() int32 {
	if x != nil {
		return x.Partitions
	}
	return 0
}

func (x *CreateTopicRequest) GetReplicationFactor() int32 {
	if x != nil {
		return x.ReplicationFactor
	}
	return 0
}

func (x *CreateTopicRequest) GetRetentionMs() int64 {
	if x != nil {
		return x.RetentionMs
	}
	return 0
}

func (x *CreateTopicRequest) GetCleanupPolicy() string {
	if x != nil {
		return x.CleanupPolicy
	}
	return ""
}

func (x *CreateTopicRequest) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *CreateTopicRequest) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *CreateTopicRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CreateTopicRequest) GetSchema() *KafkaSchema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type CreateTopicResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         *KafkaTopic            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	WorkflowId    string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicResponse) Reset() {
	*x = CreateTopicResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicResponse) ProtoMessage() {}

func (x *CreateTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTopicResponse.ProtoReflect.Descriptor instead.
func (*CreateTopicResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{35}
}

func (x *CreateTopicResponse) GetTopic() *KafkaTopic {
	if x != nil {
		return x.Topic
	}
	return nil
}

func (x *CreateTopicResponse) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *CreateTopicResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type GetTopicRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicRequest) Reset() {
	*x = GetTopicRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicRequest) ProtoMessage() {}

func (x *GetTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicRequest.ProtoReflect.Descriptor instead.
func (*GetTopicRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{36}
}

func (x *GetTopicRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

type GetTopicResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         *KafkaTopic            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicResponse) Reset() {
	*x = GetTopicResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicResponse) ProtoMessage() {}

func (x *GetTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicResponse.ProtoReflect.Descriptor instead.
func (*GetTopicResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{37}
}

func (x *GetTopicResponse) GetTopic() *KafkaTopic {
	if x != nil {
		return x.Topic
	}
	return nil
}

func (x *GetTopicResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListTopicsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkspaceId   string                 `protobuf:"bytes,1,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Environment   string                 `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment,omitempty"`
	Status        TopicStatus            `protobuf:"varint,3,opt,name=status,proto3,enum=idp.kafka.v1.TopicStatus" json:"status,omitempty"`
	Limit         int32                  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset        int32                  `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTopicsRequest) Reset() {
	*x = ListTopicsRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTopicsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTopicsRequest) ProtoMessage() {}

func (x *ListTopicsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTopicsRequest.ProtoReflect.Descriptor instead.
func (*ListTopicsRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{38}
}

func (x *ListTopicsRequest) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *ListTopicsRequest) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *ListTopicsRequest) GetStatus() TopicStatus {
	if x != nil {
		return x.Status
	}
	return TopicStatus_TOPIC_STATUS_UNSPECIFIED
}

func (x *ListTopicsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListTopicsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type ListTopicsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topics        []*KafkaTopic          `protobuf:"bytes,1,rep,name=topics,proto3" json:"topics,omitempty"`
	Total         int32                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTopicsResponse) Reset() {
	*x = ListTopicsResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTopicsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTopicsResponse) ProtoMessage() {}

func (x *ListTopicsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTopicsResponse.ProtoReflect.Descriptor instead.
func (*ListTopicsResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{39}
}

func (x *ListTopicsResponse) GetTopics() []*KafkaTopic {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *ListTopicsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

type UpdateTopicRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Partitions    *int32                 `protobuf:"varint,2,opt,name=partitions,proto3,oneof" json:"partitions,omitempty"`
	RetentionMs   *int64                 `protobuf:"varint,3,opt,name=retention_ms,json=retentionMs,proto3,oneof" json:"retention_ms,omitempty"`
	Config        map[string]string      `protobuf:"bytes,4,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Description   *string                `protobuf:"bytes,5,opt,name=description,proto3,oneof" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTopicRequest) Reset() {
	*x = UpdateTopicRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTopicRequest) ProtoMessage() {}

func (x *UpdateTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTopicRequest.ProtoReflect.Descriptor instead.
func (*UpdateTopicRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{40}
}

func (x *UpdateTopicRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *UpdateTopicRequest) GetPartitions() int32 {
	if x != nil && x.Partitions != nil {
		return *x.Partitions
	}
	return 0
}

func (x *UpdateTopicRequest) GetRetentionMs() int64 {
	if x != nil && x.RetentionMs != nil {
		return *x.RetentionMs
	}
	return 0
}

func (x *UpdateTopicRequest) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *UpdateTopicRequest) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

type UpdateTopicResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         *KafkaTopic            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTopicResponse) Reset() {
	*x = UpdateTopicResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTopicResponse) ProtoMessage() {}

func (x *UpdateTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTopicResponse.ProtoReflect.Descriptor instead.
func (*UpdateTopicResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{41}
}

func (x *UpdateTopicResponse) GetTopic() *KafkaTopic {
	if x != nil {
		return x.Topic
	}
	return nil
}

func (x *UpdateTopicResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type DeleteTopicRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteTopicRequest) Reset() {
	*x = DeleteTopicRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteTopicRequest) ProtoMessage() {}

func (x *DeleteTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteTopicRequest.ProtoReflect.Descriptor instead.
func (*DeleteTopicRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{42}
}

func (x *DeleteTopicRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

type DeleteTopicResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	WorkflowId    string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteTopicResponse) Reset() {
	*x = DeleteTopicResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteTopicResponse) ProtoMessage() {}

func (x *DeleteTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteTopicResponse.ProtoReflect.Descriptor instead.
func (*DeleteTopicResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{43}
}

func (x *DeleteTopicResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DeleteTopicResponse) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *DeleteTopicResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ApproveTopicRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	ApprovedBy    string                 `protobuf:"bytes,2,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveTopicRequest) Reset() {
	*x = ApproveTopicRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveTopicRequest) ProtoMessage() {}

func (x *ApproveTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveTopicRequest.ProtoReflect.Descriptor instead.
func (*ApproveTopicRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{44}
}

func (x *ApproveTopicRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *ApproveTopicRequest) GetApprovedBy() string {
	if x != nil {
		return x.ApprovedBy
	}
	return ""
}

type ApproveTopicResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         *KafkaTopic            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	WorkflowId    string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveTopicResponse) Reset() {
	*x = ApproveTopicResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveTopicResponse) ProtoMessage() {}

func (x *ApproveTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveTopicResponse.ProtoReflect.Descriptor instead.
func (*ApproveTopicResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{45}
}

func (x *ApproveTopicResponse) GetTopic() *KafkaTopic {
	if x != nil {
		return x.Topic
	}
	return nil
}

func (x *ApproveTopicResponse) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *ApproveTopicResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Schema Management
type RegisterSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Type          string                 `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"` // "key" or "value"
	Format        SchemaFormat           `protobuf:"varint,3,opt,name=format,proto3,enum=idp.kafka.v1.SchemaFormat" json:"format,omitempty"`
	Content       string                 `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	Compatibility SchemaCompatibility    `protobuf:"varint,5,opt,name=compatibility,proto3,enum=idp.kafka.v1.SchemaCompatibility" json:"compatibility,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterSchemaRequest) Reset() {
	*x = RegisterSchemaRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterSchemaRequest) ProtoMessage() {}

func (x *RegisterSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterSchemaRequest.ProtoReflect.Descriptor instead.
func (*RegisterSchemaRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{46}
}

func (x *RegisterSchemaRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *RegisterSchemaRequest) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *RegisterSchemaRequest) GetFormat() SchemaFormat {
	if x != nil {
		return x.Format
	}
	return SchemaFormat_SCHEMA_FORMAT_UNSPECIFIED
}

func (x *RegisterSchemaRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *RegisterSchemaRequest) GetCompatibility() SchemaCompatibility {
	if x != nil {
		return x.Compatibility
	}
	return SchemaCompatibility_SCHEMA_COMPATIBILITY_UNSPECIFIED
}

type RegisterSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *KafkaSchema           `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterSchemaResponse) Reset() {
	*x = RegisterSchemaResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterSchemaResponse) ProtoMessage() {}

func (x *RegisterSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterSchemaResponse.ProtoReflect.Descriptor instead.
func (*RegisterSchemaResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{47}
}

func (x *RegisterSchemaResponse) GetSchema() *KafkaSchema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *RegisterSchemaResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type GetSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SchemaId      string                 `protobuf:"bytes,1,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSchemaRequest) Reset() {
	*x = GetSchemaRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaRequest) ProtoMessage() {}

func (x *GetSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaRequest.ProtoReflect.Descriptor instead.
func (*GetSchemaRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{48}
}

func (x *GetSchemaRequest) GetSchemaId() string {
	if x != nil {
		return x.SchemaId
	}
	return ""
}

type GetSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *KafkaSchema           `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSchemaResponse) Reset() {
	*x = GetSchemaResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaResponse) ProtoMessage() {}

func (x *GetSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaResponse.ProtoReflect.Descriptor instead.
func (*GetSchemaResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{49}
}

func (x *GetSchemaResponse) GetSchema() *KafkaSchema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *GetSchemaResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListSchemasRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSchemasRequest) Reset() {
	*x = ListSchemasRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSchemasRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSchemasRequest) ProtoMessage() {}

func (x *ListSchemasRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSchemasRequest.ProtoReflect.Descriptor instead.
func (*ListSchemasRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{50}
}

func (x *ListSchemasRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

type ListSchemasResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schemas       []*KafkaSchema         `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSchemasResponse) Reset() {
	*x = ListSchemasResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSchemasResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSchemasResponse) ProtoMessage() {}

func (x *ListSchemasResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSchemasResponse.ProtoReflect.Descriptor instead.
func (*ListSchemasResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{51}
}

func (x *ListSchemasResponse) GetSchemas() []*KafkaSchema {
	if x != nil {
		return x.Schemas
	}
	return nil
}

type CheckSchemaCompatibilityRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Type          string                 `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Format        SchemaFormat           `protobuf:"varint,3,opt,name=format,proto3,enum=idp.kafka.v1.SchemaFormat" json:"format,omitempty"`
	Content       string                 `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckSchemaCompatibilityRequest) Reset() {
	*x = CheckSchemaCompatibilityRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckSchemaCompatibilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckSchemaCompatibilityRequest) ProtoMessage() {}

func (x *CheckSchemaCompatibilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckSchemaCompatibilityRequest.ProtoReflect.Descriptor instead.
func (*CheckSchemaCompatibilityRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{52}
}

func (x *CheckSchemaCompatibilityRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *CheckSchemaCompatibilityRequest) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *CheckSchemaCompatibilityRequest) GetFormat() SchemaFormat {
	if x != nil {
		return x.Format
	}
	return SchemaFormat_SCHEMA_FORMAT_UNSPECIFIED
}

func (x *CheckSchemaCompatibilityRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

type CheckSchemaCompatibilityResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Compatible    bool                   `protobuf:"varint,1,opt,name=compatible,proto3" json:"compatible,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckSchemaCompatibilityResponse) Reset() {
	*x = CheckSchemaCompatibilityResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckSchemaCompatibilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckSchemaCompatibilityResponse) ProtoMessage() {}

func (x *CheckSchemaCompatibilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckSchemaCompatibilityResponse.ProtoReflect.Descriptor instead.
func (*CheckSchemaCompatibilityResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{53}
}

func (x *CheckSchemaCompatibilityResponse) GetCompatible() bool {
	if x != nil {
		return x.Compatible
	}
	return false
}

func (x *CheckSchemaCompatibilityResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Service Account Management
type CreateServiceAccountRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkspaceId   string                 `protobuf:"bytes,1,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type          ServiceAccountType     `protobuf:"varint,3,opt,name=type,proto3,enum=idp.kafka.v1.ServiceAccountType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateServiceAccountRequest) Reset() {
	*x = CreateServiceAccountRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateServiceAccountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateServiceAccountRequest) ProtoMessage() {}

func (x *CreateServiceAccountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateServiceAccountRequest.ProtoReflect.Descriptor instead.
func (*CreateServiceAccountRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{54}
}

func (x *CreateServiceAccountRequest) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *CreateServiceAccountRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateServiceAccountRequest) GetType() ServiceAccountType {
	if x != nil {
		return x.Type
	}
	return ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED
}

type CreateServiceAccountResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ServiceAccount *KafkaServiceAccount   `protobuf:"bytes,1,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty"`
	ApiKey         string                 `protobuf:"bytes,2,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	ApiSecret      string                 `protobuf:"bytes,3,opt,name=api_secret,json=apiSecret,proto3" json:"api_secret,omitempty"`
	Error          string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CreateServiceAccountResponse) Reset() {
	*x = CreateServiceAccountResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateServiceAccountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateServiceAccountResponse) ProtoMessage() {}

func (x *CreateServiceAccountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateServiceAccountResponse.ProtoReflect.Descriptor instead.
func (*CreateServiceAccountResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{55}
}

func (x *CreateServiceAccountResponse) GetServiceAccount() *KafkaServiceAccount {
	if x != nil {
		return x.ServiceAccount
	}
	return nil
}

func (x *CreateServiceAccountResponse) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *CreateServiceAccountResponse) GetApiSecret() string {
	if x != nil {
		return x.ApiSecret
	}
	return ""
}

func (x *CreateServiceAccountResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListServiceAccountsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkspaceId   string                 `protobuf:"bytes,1,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListServiceAccountsRequest) Reset() {
	*x = ListServiceAccountsRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServiceAccountsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServiceAccountsRequest) ProtoMessage() {}

func (x *ListServiceAccountsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServiceAccountsRequest.ProtoReflect.Descriptor instead.
func (*ListServiceAccountsRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{56}
}

func (x *ListServiceAccountsRequest) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

type ListServiceAccountsResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ServiceAccounts []*KafkaServiceAccount `protobuf:"bytes,1,rep,name=service_accounts,json=serviceAccounts,proto3" json:"service_accounts,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListServiceAccountsResponse) Reset() {
	*x = ListServiceAccountsResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServiceAccountsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServiceAccountsResponse) ProtoMessage() {}

func (x *ListServiceAccountsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServiceAccountsResponse.ProtoReflect.Descriptor instead.
func (*ListServiceAccountsResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{57}
}

func (x *ListServiceAccountsResponse) GetServiceAccounts() []*KafkaServiceAccount {
	if x != nil {
		return x.ServiceAccounts
	}
	return nil
}

type RevokeServiceAccountRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ServiceAccountId string                 `protobuf:"bytes,1,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RevokeServiceAccountRequest) Reset() {
	*x = RevokeServiceAccountRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeServiceAccountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeServiceAccountRequest) ProtoMessage() {}

func (x *RevokeServiceAccountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeServiceAccountRequest.ProtoReflect.Descriptor instead.
func (*RevokeServiceAccountRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{58}
}

func (x *RevokeServiceAccountRequest) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

type RevokeServiceAccountResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeServiceAccountResponse) Reset() {
	*x = RevokeServiceAccountResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeServiceAccountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeServiceAccountResponse) ProtoMessage() {}

func (x *RevokeServiceAccountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeServiceAccountResponse.ProtoReflect.Descriptor instead.
func (*RevokeServiceAccountResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{59}
}

func (x *RevokeServiceAccountResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RevokeServiceAccountResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Topic Sharing
type RequestTopicAccessRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	TopicId               string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	RequestingWorkspaceId string                 `protobuf:"bytes,2,opt,name=requesting_workspace_id,json=requestingWorkspaceId,proto3" json:"requesting_workspace_id,omitempty"`
	Permission            SharePermission        `protobuf:"varint,3,opt,name=permission,proto3,enum=idp.kafka.v1.SharePermission" json:"permission,omitempty"`
	Justification         string                 `protobuf:"bytes,4,opt,name=justification,proto3" json:"justification,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *RequestTopicAccessRequest) Reset() {
	*x = RequestTopicAccessRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestTopicAccessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestTopicAccessRequest) ProtoMessage() {}

func (x *RequestTopicAccessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestTopicAccessRequest.ProtoReflect.Descriptor instead.
func (*RequestTopicAccessRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{60}
}

func (x *RequestTopicAccessRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *RequestTopicAccessRequest) GetRequestingWorkspaceId() string {
	if x != nil {
		return x.RequestingWorkspaceId
	}
	return ""
}

func (x *RequestTopicAccessRequest) GetPermission() SharePermission {
	if x != nil {
		return x.Permission
	}
	return SharePermission_SHARE_PERMISSION_UNSPECIFIED
}

func (x *RequestTopicAccessRequest) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

type RequestTopicAccessResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Share         *KafkaTopicShare       `protobuf:"bytes,1,opt,name=share,proto3" json:"share,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestTopicAccessResponse) Reset() {
	*x = RequestTopicAccessResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestTopicAccessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestTopicAccessResponse) ProtoMessage() {}

func (x *RequestTopicAccessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestTopicAccessResponse.ProtoReflect.Descriptor instead.
func (*RequestTopicAccessResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{61}
}

func (x *RequestTopicAccessResponse) GetShare() *KafkaTopicShare {
	if x != nil {
		return x.Share
	}
	return nil
}

func (x *RequestTopicAccessResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ApproveTopicAccessRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ShareId       string                 `protobuf:"bytes,1,opt,name=share_id,json=shareId,proto3" json:"share_id,omitempty"`
	ApprovedBy    string                 `protobuf:"bytes,2,opt,name=approved_by,json=approvedBy,proto3" json:"approved_by,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveTopicAccessRequest) Reset() {
	*x = ApproveTopicAccessRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveTopicAccessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveTopicAccessRequest) ProtoMessage() {}

func (x *ApproveTopicAccessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveTopicAccessRequest.ProtoReflect.Descriptor instead.
func (*ApproveTopicAccessRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{62}
}

func (x *ApproveTopicAccessRequest) GetShareId() string {
	if x != nil {
		return x.ShareId
	}
	return ""
}

func (x *ApproveTopicAccessRequest) GetApprovedBy() string {
	if x != nil {
		return x.ApprovedBy
	}
	return ""
}

type ApproveTopicAccessResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Share         *KafkaTopicShare       `protobuf:"bytes,1,opt,name=share,proto3" json:"share,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveTopicAccessResponse) Reset() {
	*x = ApproveTopicAccessResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveTopicAccessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveTopicAccessResponse) ProtoMessage() {}

func (x *ApproveTopicAccessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveTopicAccessResponse.ProtoReflect.Descriptor instead.
func (*ApproveTopicAccessResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{63}
}

func (x *ApproveTopicAccessResponse) GetShare() *KafkaTopicShare {
	if x != nil {
		return x.Share
	}
	return nil
}

func (x *ApproveTopicAccessResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RevokeTopicAccessRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ShareId       string                 `protobuf:"bytes,1,opt,name=share_id,json=shareId,proto3" json:"share_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeTopicAccessRequest) Reset() {
	*x = RevokeTopicAccessRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeTopicAccessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeTopicAccessRequest) ProtoMessage() {}

func (x *RevokeTopicAccessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeTopicAccessRequest.ProtoReflect.Descriptor instead.
func (*RevokeTopicAccessRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{64}
}

func (x *RevokeTopicAccessRequest) GetShareId() string {
	if x != nil {
		return x.ShareId
	}
	return ""
}

type RevokeTopicAccessResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeTopicAccessResponse) Reset() {
	*x = RevokeTopicAccessResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeTopicAccessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeTopicAccessResponse) ProtoMessage() {}

func (x *RevokeTopicAccessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeTopicAccessResponse.ProtoReflect.Descriptor instead.
func (*RevokeTopicAccessResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{65}
}

func (x *RevokeTopicAccessResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RevokeTopicAccessResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListTopicSharesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	WorkspaceId   string                 `protobuf:"bytes,2,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	Status        ShareStatus            `protobuf:"varint,3,opt,name=status,proto3,enum=idp.kafka.v1.ShareStatus" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTopicSharesRequest) Reset() {
	*x = ListTopicSharesRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTopicSharesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTopicSharesRequest) ProtoMessage() {}

func (x *ListTopicSharesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTopicSharesRequest.ProtoReflect.Descriptor instead.
func (*ListTopicSharesRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{66}
}

func (x *ListTopicSharesRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *ListTopicSharesRequest) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *ListTopicSharesRequest) GetStatus() ShareStatus {
	if x != nil {
		return x.Status
	}
	return ShareStatus_SHARE_STATUS_UNSPECIFIED
}

type ListTopicSharesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Shares        []*KafkaTopicShare     `protobuf:"bytes,1,rep,name=shares,proto3" json:"shares,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTopicSharesResponse) Reset() {
	*x = ListTopicSharesResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTopicSharesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTopicSharesResponse) ProtoMessage() {}

func (x *ListTopicSharesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTopicSharesResponse.ProtoReflect.Descriptor instead.
func (*ListTopicSharesResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{67}
}

func (x *ListTopicSharesResponse) GetShares() []*KafkaTopicShare {
	if x != nil {
		return x.Shares
	}
	return nil
}

// Discovery
type DiscoverTopicsRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	RequestingWorkspaceId string                 `protobuf:"bytes,1,opt,name=requesting_workspace_id,json=requestingWorkspaceId,proto3" json:"requesting_workspace_id,omitempty"`
	Environment           string                 `protobuf:"bytes,2,opt,name=environment,proto3" json:"environment,omitempty"`
	Search                string                 `protobuf:"bytes,3,opt,name=search,proto3" json:"search,omitempty"`
	SchemaFormat          SchemaFormat           `protobuf:"varint,4,opt,name=schema_format,json=schemaFormat,proto3,enum=idp.kafka.v1.SchemaFormat" json:"schema_format,omitempty"`
	Limit                 int32                  `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset                int32                  `protobuf:"varint,6,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *DiscoverTopicsRequest) Reset() {
	*x = DiscoverTopicsRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoverTopicsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverTopicsRequest) ProtoMessage() {}

func (x *DiscoverTopicsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverTopicsRequest.ProtoReflect.Descriptor instead.
func (*DiscoverTopicsRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{68}
}

func (x *DiscoverTopicsRequest) GetRequestingWorkspaceId() string {
	if x != nil {
		return x.RequestingWorkspaceId
	}
	return ""
}

func (x *DiscoverTopicsRequest) GetEnvironment() string {
	if x != nil {
		return x.Environment
	}
	return ""
}

func (x *DiscoverTopicsRequest) GetSearch() string {
	if x != nil {
		return x.Search
	}
	return ""
}

func (x *DiscoverTopicsRequest) GetSchemaFormat() SchemaFormat {
	if x != nil {
		return x.SchemaFormat
	}
	return SchemaFormat_SCHEMA_FORMAT_UNSPECIFIED
}

func (x *DiscoverTopicsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *DiscoverTopicsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type DiscoverTopicsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topics        []*DiscoverableTopic   `protobuf:"bytes,1,rep,name=topics,proto3" json:"topics,omitempty"`
	Total         int32                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiscoverTopicsResponse) Reset() {
	*x = DiscoverTopicsResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoverTopicsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverTopicsResponse) ProtoMessage() {}

func (x *DiscoverTopicsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverTopicsResponse.ProtoReflect.Descriptor instead.
func (*DiscoverTopicsResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{69}
}

func (x *DiscoverTopicsResponse) GetTopics() []*DiscoverableTopic {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *DiscoverTopicsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

type DiscoverableTopic struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Topic               *KafkaTopic            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	OwningWorkspaceName string                 `protobuf:"bytes,2,opt,name=owning_workspace_name,json=owningWorkspaceName,proto3" json:"owning_workspace_name,omitempty"`
	Visibility          TopicVisibility        `protobuf:"varint,3,opt,name=visibility,proto3,enum=idp.kafka.v1.TopicVisibility" json:"visibility,omitempty"`
	AccessStatus        string                 `protobuf:"bytes,4,opt,name=access_status,json=accessStatus,proto3" json:"access_status,omitempty"` // "member", "has_access", "can_request", "public"
	HasSchema           bool                   `protobuf:"varint,5,opt,name=has_schema,json=hasSchema,proto3" json:"has_schema,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DiscoverableTopic) Reset() {
	*x = DiscoverableTopic{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoverableTopic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverableTopic) ProtoMessage() {}

func (x *DiscoverableTopic) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverableTopic.ProtoReflect.Descriptor instead.
func (*DiscoverableTopic) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{70}
}

func (x *DiscoverableTopic) GetTopic() *KafkaTopic {
	if x != nil {
		return x.Topic
	}
	return nil
}

func (x *DiscoverableTopic) GetOwningWorkspaceName() string {
	if x != nil {
		return x.OwningWorkspaceName
	}
	return ""
}

func (x *DiscoverableTopic) GetVisibility() TopicVisibility {
	if x != nil {
		return x.Visibility
	}
	return TopicVisibility_TOPIC_VISIBILITY_UNSPECIFIED
}

func (x *DiscoverableTopic) GetAccessStatus() string {
	if x != nil {
		return x.AccessStatus
	}
	return ""
}

func (x *DiscoverableTopic) GetHasSchema() bool {
	if x != nil {
		return x.HasSchema
	}
	return false
}

// Metrics & Lineage
type GetTopicMetricsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	PeriodType    string                 `protobuf:"bytes,2,opt,name=period_type,json=periodType,proto3" json:"period_type,omitempty"` // "hourly" or "daily"
	Periods       int32                  `protobuf:"varint,3,opt,name=periods,proto3" json:"periods,omitempty"`                        // number of periods to return
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicMetricsRequest) Reset() {
	*x = GetTopicMetricsRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicMetricsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicMetricsRequest) ProtoMessage() {}

func (x *GetTopicMetricsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicMetricsRequest.ProtoReflect.Descriptor instead.
func (*GetTopicMetricsRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{71}
}

func (x *GetTopicMetricsRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

func (x *GetTopicMetricsRequest) GetPeriodType() string {
	if x != nil {
		return x.PeriodType
	}
	return ""
}

func (x *GetTopicMetricsRequest) GetPeriods() int32 {
	if x != nil {
		return x.Periods
	}
	return 0
}

type GetTopicMetricsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metrics       []*KafkaUsageMetrics   `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicMetricsResponse) Reset() {
	*x = GetTopicMetricsResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicMetricsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicMetricsResponse) ProtoMessage() {}

func (x *GetTopicMetricsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicMetricsResponse.ProtoReflect.Descriptor instead.
func (*GetTopicMetricsResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{72}
}

func (x *GetTopicMetricsResponse) GetMetrics() []*KafkaUsageMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

type GetTopicLineageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopicId       string                 `protobuf:"bytes,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicLineageRequest) Reset() {
	*x = GetTopicLineageRequest{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicLineageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicLineageRequest) ProtoMessage() {}

func (x *GetTopicLineageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicLineageRequest.ProtoReflect.Descriptor instead.
func (*GetTopicLineageRequest) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{73}
}

func (x *GetTopicLineageRequest) GetTopicId() string {
	if x != nil {
		return x.TopicId
	}
	return ""
}

type GetTopicLineageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Producers     []*LineageNode         `protobuf:"bytes,1,rep,name=producers,proto3" json:"producers,omitempty"`
	Consumers     []*LineageNode         `protobuf:"bytes,2,rep,name=consumers,proto3" json:"consumers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTopicLineageResponse) Reset() {
	*x = GetTopicLineageResponse{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTopicLineageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTopicLineageResponse) ProtoMessage() {}

func (x *GetTopicLineageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTopicLineageResponse.ProtoReflect.Descriptor instead.
func (*GetTopicLineageResponse) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{74}
}

func (x *GetTopicLineageResponse) GetProducers() []*LineageNode {
	if x != nil {
		return x.Producers
	}
	return nil
}

func (x *GetTopicLineageResponse) GetConsumers() []*LineageNode {
	if x != nil {
		return x.Consumers
	}
	return nil
}

type LineageNode struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	WorkspaceId        string                 `protobuf:"bytes,1,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"`
	WorkspaceName      string                 `protobuf:"bytes,2,opt,name=workspace_name,json=workspaceName,proto3" json:"workspace_name,omitempty"`
	ServiceAccountId   string                 `protobuf:"bytes,3,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	ServiceAccountName string                 `protobuf:"bytes,4,opt,name=service_account_name,json=serviceAccountName,proto3" json:"service_account_name,omitempty"`
	ClientId           string                 `protobuf:"bytes,5,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	BytesTransferred   int64                  `protobuf:"varint,6,opt,name=bytes_transferred,json=bytesTransferred,proto3" json:"bytes_transferred,omitempty"`
	LastSeen           *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LineageNode) Reset() {
	*x = LineageNode{}
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LineageNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LineageNode) ProtoMessage() {}

func (x *LineageNode) ProtoReflect() protoreflect.Message {
	mi := &file_idp_kafka_v1_kafka_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LineageNode.ProtoReflect.Descriptor instead.
func (*LineageNode) Descriptor() ([]byte, []int) {
	return file_idp_kafka_v1_kafka_proto_rawDescGZIP(), []int{75}
}

func (x *LineageNode) GetWorkspaceId() string {
	if x != nil {
		return x.WorkspaceId
	}
	return ""
}

func (x *LineageNode) GetWorkspaceName() string {
	if x != nil {
		return x.WorkspaceName
	}
	return ""
}

func (x *LineageNode) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *LineageNode) GetServiceAccountName() string {
	if x != nil {
		return x.ServiceAccountName
	}
	return ""
}

func (x *LineageNode) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *LineageNode) GetBytesTransferred() int64 {
	if x != nil {
		return x.BytesTransferred
	}
	return 0
}

func (x *LineageNode) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

var File_idp_kafka_v1_kafka_proto protoreflect.FileDescriptor

const file_idp_kafka_v1_kafka_proto_rawDesc = "" +
	"\n" +
	"\x18idp/kafka/v1/kafka.proto\x12\fidp.kafka.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xbf\x02\n" +
	"\rKafkaProvider\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12!\n" +
	"\fdisplay_name\x18\x03 \x01(\tR\vdisplayName\x12!\n" +
	"\fadapter_type\x18\x04 \x01(\tR\vadapterType\x124\n" +
	"\x16required_config_fields\x18\x05 \x03(\tR\x14requiredConfigFields\x12F\n" +
	"\fcapabilities\x18\x06 \x01(\v2\".idp.kafka.v1.ProviderCapabilitiesR\fcapabilities\x12+\n" +
	"\x11documentation_url\x18\a \x01(\tR\x10documentationUrl\x12\x19\n" +
	"\bicon_url\x18\b \x01(\tR\aiconUrl\"\xa3\x01\n" +
	"\x14ProviderCapabilities\x12'\n" +
	"\x0fschema_registry\x18\x01 \x01(\bR\x0eschemaRegistry\x12\"\n" +
	"\ftransactions\x18\x02 \x01(\bR\ftransactions\x12\x1d\n" +
	"\n" +
	"quotas_api\x18\x03 \x01(\bR\tquotasApi\x12\x1f\n" +
	"\vmetrics_api\x18\x04 \x01(\bR\n" +
	"metricsApi\"\x89\x04\n" +
	"\fKafkaCluster\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1f\n" +
	"\vprovider_id\x18\x03 \x01(\tR\n" +
	"providerId\x12]\n" +
	"\x11connection_config\x18\x04 \x03(\v20.idp.kafka.v1.KafkaCluster.ConnectionConfigEntryR\x10connectionConfig\x12R\n" +
	"\x11validation_status\x18\x05 \x01(\x0e2%.idp.kafka.v1.ClusterValidationStatusR\x10validationStatus\x12F\n" +
	"\x11last_validated_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x0flastValidatedAt\x129\n" +
	"\n" +
	"created_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1aC\n" +
	"\x15ConnectionConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc0\x02\n" +
	"\x17KafkaEnvironmentMapping\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12 \n" +
	"\venvironment\x18\x02 \x01(\tR\venvironment\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x03 \x01(\tR\tclusterId\x12Y\n" +
	"\frouting_rule\x18\x04 \x03(\v26.idp.kafka.v1.KafkaEnvironmentMapping.RoutingRuleEntryR\vroutingRule\x12\x1a\n" +
	"\bpriority\x18\x05 \x01(\x05R\bpriority\x12\x1d\n" +
	"\n" +
	"is_default\x18\x06 \x01(\bR\tisDefault\x1a>\n" +
	"\x10RoutingRuleEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa7\x02\n" +
	"\x0eSchemaRegistry\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x126\n" +
	"\x17subject_naming_template\x18\x03 \x01(\tR\x15subjectNamingTemplate\x12V\n" +
	"\x15default_compatibility\x18\x04 \x01(\x0e2!.idp.kafka.v1.SchemaCompatibilityR\x14defaultCompatibility\x12c\n" +
	"\x15environment_overrides\x18\x05 \x03(\v2..idp.kafka.v1.EnvironmentCompatibilityOverrideR\x14environmentOverrides\"\x8d\x01\n" +
	" EnvironmentCompatibilityOverride\x12 \n" +
	"\venvironment\x18\x01 \x01(\tR\venvironment\x12G\n" +
	"\rcompatibility\x18\x02 \x01(\x0e2!.idp.kafka.v1.SchemaCompatibilityR\rcompatibility\"\xbf\x06\n" +
	"\n" +
	"KafkaTopic\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12!\n" +
	"\fworkspace_id\x18\x02 \x01(\tR\vworkspaceId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\venvironment\x18\x04 \x01(\tR\venvironment\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x05 \x01(\tR\tclusterId\x12\x1e\n" +
	"\n" +
	"partitions\x18\x06 \x01(\x05R\n" +
	"partitions\x12-\n" +
	"\x12replication_factor\x18\a \x01(\x05R\x11replicationFactor\x12!\n" +
	"\fretention_ms\x18\b \x01(\x03R\vretentionMs\x12%\n" +
	"\x0ecleanup_policy\x18\t \x01(\tR\rcleanupPolicy\x12 \n" +
	"\vcompression\x18\n" +
	" \x01(\tR\vcompression\x12<\n" +
	"\x06config\x18\v \x03(\v2$.idp.kafka.v1.KafkaTopic.ConfigEntryR\x06config\x121\n" +
	"\x06status\x18\f \x01(\x0e2\x19.idp.kafka.v1.TopicStatusR\x06status\x12\x1f\n" +
	"\vworkflow_id\x18\r \x01(\tR\n" +
	"workflowId\x12+\n" +
	"\x11approval_required\x18\x0e \x01(\bR\x10approvalRequired\x12\x1f\n" +
	"\vapproved_by\x18\x0f \x01(\tR\n" +
	"approvedBy\x12;\n" +
	"\vapproved_at\x18\x10 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"approvedAt\x129\n" +
	"\n" +
	"created_at\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\x12 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12 \n" +
	"\vdescription\x18\x13 \x01(\tR\vdescription\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe5\x03\n" +
	"\vKafkaSchema\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12!\n" +
	"\fworkspace_id\x18\x02 \x01(\tR\vworkspaceId\x12\x19\n" +
	"\btopic_id\x18\x03 \x01(\tR\atopicId\x12\x12\n" +
	"\x04type\x18\x04 \x01(\tR\x04type\x12\x18\n" +
	"\asubject\x18\x05 \x01(\tR\asubject\x122\n" +
	"\x06format\x18\x06 \x01(\x0e2\x1a.idp.kafka.v1.SchemaFormatR\x06format\x12\x18\n" +
	"\acontent\x18\a \x01(\tR\acontent\x12\x18\n" +
	"\aversion\x18\b \x01(\x05R\aversion\x12\x1b\n" +
	"\tschema_id\x18\t \x01(\x05R\bschemaId\x12G\n" +
	"\rcompatibility\x18\n" +
	" \x01(\x0e2!.idp.kafka.v1.SchemaCompatibilityR\rcompatibility\x12\x16\n" +
	"\x06status\x18\v \x01(\tR\x06status\x129\n" +
	"\n" +
	"created_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\"\x84\x02\n" +
	"\x13KafkaServiceAccount\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12!\n" +
	"\fworkspace_id\x18\x02 \x01(\tR\vworkspaceId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x124\n" +
	"\x04type\x18\x04 \x01(\x0e2 .idp.kafka.v1.ServiceAccountTypeR\x04type\x12\x16\n" +
	"\x06status\x18\x05 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"created_by\x18\x06 \x01(\tR\tcreatedBy\x129\n" +
	"\n" +
	"created_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\"\xe1\x04\n" +
	"\x0fKafkaTopicShare\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
	"\btopic_id\x18\x02 \x01(\tR\atopicId\x12(\n" +
	"\x10shared_with_type\x18\x03 \x01(\tR\x0esharedWithType\x127\n" +
	"\x18shared_with_workspace_id\x18\x04 \x01(\tR\x15sharedWithWorkspaceId\x12-\n" +
	"\x13shared_with_user_id\x18\x05 \x01(\tR\x10sharedWithUserId\x12=\n" +
	"\n" +
	"permission\x18\x06 \x01(\x0e2\x1d.idp.kafka.v1.SharePermissionR\n" +
	"permission\x121\n" +
	"\x06status\x18\a \x01(\x0e2\x19.idp.kafka.v1.ShareStatusR\x06status\x12!\n" +
	"\frequested_by\x18\b \x01(\tR\vrequestedBy\x12=\n" +
	"\frequested_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\vrequestedAt\x12$\n" +
	"\rjustification\x18\n" +
	" \x01(\tR\rjustification\x12\x1f\n" +
	"\vapproved_by\x18\v \x01(\tR\n" +
	"approvedBy\x12;\n" +
	"\vapproved_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"approvedAt\x129\n" +
	"\n" +
	"expires_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\"\xe0\x03\n" +
	"\x10KafkaTopicPolicy\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12/\n" +
	"\x05scope\x18\x02 \x01(\x0e2\x19.idp.kafka.v1.PolicyScopeR\x05scope\x12!\n" +
	"\fworkspace_id\x18\x03 \x01(\tR\vworkspaceId\x12 \n" +
	"\venvironment\x18\x04 \x01(\tR\venvironment\x12%\n" +
	"\x0enaming_pattern\x18\x05 \x01(\tR\rnamingPattern\x122\n" +
	"\x15auto_approve_patterns\x18\x06 \x03(\tR\x13autoApprovePatterns\x12H\n" +
	"\x10partition_limits\x18\a \x01(\v2\x1d.idp.kafka.v1.PartitionLimitsR\x0fpartitionLimits\x12H\n" +
	"\x10retention_limits\x18\b \x01(\v2\x1d.idp.kafka.v1.RetentionLimitsR\x0fretentionLimits\x12%\n" +
	"\x0erequire_schema\x18\t \x01(\bR\rrequireSchema\x120\n" +
	"\x14require_approval_for\x18\n" +
	" \x03(\tR\x12requireApprovalFor\"5\n" +
	"\x0fPartitionLimits\x12\x10\n" +
	"\x03min\x18\x01 \x01(\x05R\x03min\x12\x10\n" +
	"\x03max\x18\x02 \x01(\x05R\x03max\"?\n" +
	"\x0fRetentionLimits\x12\x15\n" +
	"\x06min_ms\x18\x01 \x01(\x03R\x05minMs\x12\x15\n" +
	"\x06max_ms\x18\x02 \x01(\x03R\x05maxMs\"\x90\x04\n" +
	"\x15KafkaTopicSharePolicy\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12!\n" +
	"\fworkspace_id\x18\x02 \x01(\tR\vworkspaceId\x124\n" +
	"\x05scope\x18\x03 \x01(\x0e2\x1e.idp.kafka.v1.SharePolicyScopeR\x05scope\x12#\n" +
	"\rtopic_pattern\x18\x04 \x01(\tR\ftopicPattern\x12\x19\n" +
	"\btopic_id\x18\x05 \x01(\tR\atopicId\x12 \n" +
	"\venvironment\x18\x06 \x01(\tR\venvironment\x12=\n" +
	"\n" +
	"visibility\x18\a \x01(\x0e2\x1d.idp.kafka.v1.TopicVisibilityR\n" +
	"visibility\x12B\n" +
	"\fauto_approve\x18\b \x01(\v2\x1f.idp.kafka.v1.AutoApproveConfigR\vautoApprove\x12L\n" +
	"\x12default_permission\x18\t \x01(\x0e2\x1d.idp.kafka.v1.SharePermissionR\x11defaultPermission\x123\n" +
	"\x15require_justification\x18\n" +
	" \x01(\bR\x14requireJustification\x12&\n" +
	"\x0faccess_ttl_days\x18\v \x01(\x05R\raccessTtlDays\"\xd3\x01\n" +
	"\x11AutoApproveConfig\x12\"\n" +
	"\fenvironments\x18\x01 \x03(\tR\fenvironments\x12?\n" +
	"\vpermissions\x18\x02 \x03(\x0e2\x1d.idp.kafka.v1.SharePermissionR\vpermissions\x12/\n" +
	"\x13workspace_whitelist\x18\x03 \x03(\tR\x12workspaceWhitelist\x12(\n" +
	"\x10same_tenant_only\x18\x04 \x01(\bR\x0esameTenantOnly\"\xd3\x02\n" +
	"\x11KafkaUsageMetrics\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
	"\btopic_id\x18\x02 \x01(\tR\atopicId\x12\x16\n" +
	"\x06period\x18\x03 \x01(\tR\x06period\x12\x1f\n" +
	"\vperiod_type\x18\x04 \x01(\tR\n" +
	"periodType\x12\x19\n" +
	"\bbytes_in\x18\x05 \x01(\x03R\abytesIn\x12\x1b\n" +
	"\tbytes_out\x18\x06 \x01(\x03R\bbytesOut\x12(\n" +
	"\x10message_count_in\x18\a \x01(\x03R\x0emessageCountIn\x12*\n" +
	"\x11message_count_out\x18\b \x01(\x03R\x0fmessageCountOut\x12#\n" +
	"\rstorage_bytes\x18\t \x01(\x03R\fstorageBytes\x12'\n" +
	"\x0fpartition_count\x18\n" +
	" \x01(\x05R\x0epartitionCount\"\xe5\x02\n" +
	"\x12KafkaConsumerGroup\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
	"\bgroup_id\x18\x02 \x01(\tR\agroupId\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x03 \x01(\tR\tclusterId\x12\x1b\n" +
	"\ttopic_ids\x18\x04 \x03(\tR\btopicIds\x12,\n" +
	"\x12service_account_id\x18\x05 \x01(\tR\x10serviceAccountId\x12!\n" +
	"\fworkspace_id\x18\x06 \x01(\tR\vworkspaceId\x12\x1f\n" +
	"\vcurrent_lag\x18\a \x01(\x03R\n" +
	"currentLag\x127\n" +
	"\tlast_seen\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen\x12=\n" +
	"\flast_updated\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\vlastUpdated\"\xde\x02\n" +
	"\x13KafkaClientActivity\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tclient_id\x18\x02 \x01(\tR\bclientId\x12,\n" +
	"\x12service_account_id\x18\x03 \x01(\tR\x10serviceAccountId\x12!\n" +
	"\fworkspace_id\x18\x04 \x01(\tR\vworkspaceId\x12\x19\n" +
	"\btopic_id\x18\x05 \x01(\tR\atopicId\x12\x1c\n" +
	"\tdirection\x18\x06 \x01(\tR\tdirection\x12*\n" +
	"\x11consumer_group_id\x18\a \x01(\tR\x0fconsumerGroupId\x12+\n" +
	"\x11bytes_transferred\x18\b \x01(\x03R\x10bytesTransferred\x127\n" +
	"\tlast_seen\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen\"\x16\n" +
	"\x14ListProvidersRequest\"R\n" +
	"\x15ListProvidersResponse\x129\n" +
	"\tproviders\x18\x01 \x03(\v2\x1b.idp.kafka.v1.KafkaProviderR\tproviders\"\x94\x03\n" +
	"\x16RegisterClusterRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1f\n" +
	"\vprovider_id\x18\x02 \x01(\tR\n" +
	"providerId\x12g\n" +
	"\x11connection_config\x18\x03 \x03(\v2:.idp.kafka.v1.RegisterClusterRequest.ConnectionConfigEntryR\x10connectionConfig\x12W\n" +
	"\vcredentials\x18\x04 \x03(\v25.idp.kafka.v1.RegisterClusterRequest.CredentialsEntryR\vcredentials\x1aC\n" +
	"\x15ConnectionConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10CredentialsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"e\n" +
	"\x17RegisterClusterResponse\x124\n" +
	"\acluster\x18\x01 \x01(\v2\x1a.idp.kafka.v1.KafkaClusterR\acluster\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"7\n" +
	"\x16ValidateClusterRequest\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tR\tclusterId\"E\n" +
	"\x17ValidateClusterResponse\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x15\n" +
	"\x13ListClustersRequest\"N\n" +
	"\x14ListClustersResponse\x126\n" +
	"\bclusters\x18\x01 \x03(\v2\x1a.idp.kafka.v1.KafkaClusterR\bclusters\"5\n" +
	"\x14DeleteClusterRequest\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tR\tclusterId\"G\n" +
	"\x15DeleteClusterResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xc0\x02\n" +
	"\x1fCreateEnvironmentMappingRequest\x12 \n" +
	"\venvironment\x18\x01 \x01(\tR\venvironment\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x02 \x01(\tR\tclusterId\x12a\n" +
	"\frouting_rule\x18\x03 \x03(\v2>.idp.kafka.v1.CreateEnvironmentMappingRequest.RoutingRuleEntryR\vroutingRule\x12\x1a\n" +
	"\bpriority\x18\x04 \x01(\x05R\bpriority\x12\x1d\n" +
	"\n" +
	"is_default\x18\x05 \x01(\bR\tisDefault\x1a>\n" +
	"\x10RoutingRuleEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"y\n" +
	" CreateEnvironmentMappingResponse\x12?\n" +
	"\amapping\x18\x01 \x01(\v2%.idp.kafka.v1.KafkaEnvironmentMappingR\amapping\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"B\n" +
	"\x1eListEnvironmentMappingsRequest\x12 \n" +
	"\venvironment\x18\x01 \x01(\tR\venvironment\"d\n" +
	"\x1fListEnvironmentMappingsResponse\x12A\n" +
	"\bmappings\x18\x01 \x03(\v2%.idp.kafka.v1.KafkaEnvironmentMappingR\bmappings\"@\n" +
	"\x1fDeleteEnvironmentMappingRequest\x12\x1d\n" +
	"\n" +
	"mapping_id\x18\x01 \x01(\tR\tmappingId\"R\n" +
	" DeleteEnvironmentMappingResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xfe\x03\n" +
	"\x12CreateTopicRequest\x12!\n" +
	"\fworkspace_id\x18\x01 \x01(\tR\vworkspaceId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\venvironment\x18\x03 \x01(\tR\venvironment\x12\x1e\n" +
	"\n" +
	"partitions\x18\x04 \x01(\x05R\n" +
	"partitions\x12-\n" +
	"\x12replication_factor\x18\x05 \x01(\x05R\x11replicationFactor\x12!\n" +
	"\fretention_ms\x18\x06 \x01(\x03R\vretentionMs\x12%\n" +
	"\x0ecleanup_policy\x18\a \x01(\tR\rcleanupPolicy\x12 \n" +
	"\vcompression\x18\b \x01(\tR\vcompression\x12D\n" +
	"\x06config\x18\t \x03(\v2,.idp.kafka.v1.CreateTopicRequest.ConfigEntryR\x06config\x12 \n" +
	"\vdescription\x18\n" +
	" \x01(\tR\vdescription\x121\n" +
	"\x06schema\x18\v \x01(\v2\x19.idp.kafka.v1.KafkaSchemaR\x06schema\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"|\n" +
	"\x13CreateTopicResponse\x12.\n" +
	"\x05topic\x18\x01 \x01(\v2\x18.idp.kafka.v1.KafkaTopicR\x05topic\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\",\n" +
	"\x0fGetTopicRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\"X\n" +
	"\x10GetTopicResponse\x12.\n" +
	"\x05topic\x18\x01 \x01(\v2\x18.idp.kafka.v1.KafkaTopicR\x05topic\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xb9\x01\n" +
	"\x11ListTopicsRequest\x12!\n" +
	"\fworkspace_id\x18\x01 \x01(\tR\vworkspaceId\x12 \n" +
	"\venvironment\x18\x02 \x01(\tR\venvironment\x121\n" +
	"\x06status\x18\x03 \x01(\x0e2\x19.idp.kafka.v1.TopicStatusR\x06status\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x05R\x06offset\"\\\n" +
	"\x12ListTopicsResponse\x120\n" +
	"\x06topics\x18\x01 \x03(\v2\x18.idp.kafka.v1.KafkaTopicR\x06topics\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xd4\x02\n" +
	"\x12UpdateTopicRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12#\n" +
	"\n" +
	"partitions\x18\x02 \x01(\x05H\x00R\n" +
	"partitions\x88\x01\x01\x12&\n" +
	"\fretention_ms\x18\x03 \x01(\x03H\x01R\vretentionMs\x88\x01\x01\x12D\n" +
	"\x06config\x18\x04 \x03(\v2,.idp.kafka.v1.UpdateTopicRequest.ConfigEntryR\x06config\x12%\n" +
	"\vdescription\x18\x05 \x01(\tH\x02R\vdescription\x88\x01\x01\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\r\n" +
	"\v_partitionsB\x0f\n" +
	"\r_retention_msB\x0e\n" +
	"\f_description\"[\n" +
	"\x13UpdateTopicResponse\x12.\n" +
	"\x05topic\x18\x01 \x01(\v2\x18.idp.kafka.v1.KafkaTopicR\x05topic\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"/\n" +
	"\x12DeleteTopicRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\"f\n" +
	"\x13DeleteTopicResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"Q\n" +
	"\x13ApproveTopicRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12\x1f\n" +
	"\vapproved_by\x18\x02 \x01(\tR\n" +
	"approvedBy\"}\n" +
	"\x14ApproveTopicResponse\x12.\n" +
	"\x05topic\x18\x01 \x01(\v2\x18.idp.kafka.v1.KafkaTopicR\x05topic\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\xdd\x01\n" +
	"\x15RegisterSchemaRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x122\n" +
	"\x06format\x18\x03 \x01(\x0e2\x1a.idp.kafka.v1.SchemaFormatR\x06format\x12\x18\n" +
	"\acontent\x18\x04 \x01(\tR\acontent\x12G\n" +
	"\rcompatibility\x18\x05 \x01(\x0e2!.idp.kafka.v1.SchemaCompatibilityR\rcompatibility\"a\n" +
	"\x16RegisterSchemaResponse\x121\n" +
	"\x06schema\x18\x01 \x01(\v2\x19.idp.kafka.v1.KafkaSchemaR\x06schema\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"/\n" +
	"\x10GetSchemaRequest\x12\x1b\n" +
	"\tschema_id\x18\x01 \x01(\tR\bschemaId\"\\\n" +
	"\x11GetSchemaResponse\x121\n" +
	"\x06schema\x18\x01 \x01(\v2\x19.idp.kafka.v1.KafkaSchemaR\x06schema\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"/\n" +
	"\x12ListSchemasRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\"J\n" +
	"\x13ListSchemasResponse\x123\n" +
	"\aschemas\x18\x01 \x03(\v2\x19.idp.kafka.v1.KafkaSchemaR\aschemas\"\x9e\x01\n" +
	"\x1fCheckSchemaCompatibilityRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x122\n" +
	"\x06format\x18\x03 \x01(\x0e2\x1a.idp.kafka.v1.SchemaFormatR\x06format\x12\x18\n" +
	"\acontent\x18\x04 \x01(\tR\acontent\"X\n" +
	" CheckSchemaCompatibilityResponse\x12\x1e\n" +
	"\n" +
	"compatible\x18\x01 \x01(\bR\n" +
	"compatible\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x8a\x01\n" +
	"\x1bCreateServiceAccountRequest\x12!\n" +
	"\fworkspace_id\x18\x01 \x01(\tR\vworkspaceId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x124\n" +
	"\x04type\x18\x03 \x01(\x0e2 .idp.kafka.v1.ServiceAccountTypeR\x04type\"\xb8\x01\n" +
	"\x1cCreateServiceAccountResponse\x12J\n" +
	"\x0fservice_account\x18\x01 \x01(\v2!.idp.kafka.v1.KafkaServiceAccountR\x0eserviceAccount\x12\x17\n" +
	"\aapi_key\x18\x02 \x01(\tR\x06apiKey\x12\x1d\n" +
	"\n" +
	"api_secret\x18\x03 \x01(\tR\tapiSecret\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\"?\n" +
	"\x1aListServiceAccountsRequest\x12!\n" +
	"\fworkspace_id\x18\x01 \x01(\tR\vworkspaceId\"k\n" +
	"\x1bListServiceAccountsResponse\x12L\n" +
	"\x10service_accounts\x18\x01 \x03(\v2!.idp.kafka.v1.KafkaServiceAccountR\x0fserviceAccounts\"K\n" +
	"\x1bRevokeServiceAccountRequest\x12,\n" +
	"\x12service_account_id\x18\x01 \x01(\tR\x10serviceAccountId\"N\n" +
	"\x1cRevokeServiceAccountResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xd3\x01\n" +
	"\x19RequestTopicAccessRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x126\n" +
	"\x17requesting_workspace_id\x18\x02 \x01(\tR\x15requestingWorkspaceId\x12=\n" +
	"\n" +
	"permission\x18\x03 \x01(\x0e2\x1d.idp.kafka.v1.SharePermissionR\n" +
	"permission\x12$\n" +
	"\rjustification\x18\x04 \x01(\tR\rjustification\"g\n" +
	"\x1aRequestTopicAccessResponse\x123\n" +
	"\x05share\x18\x01 \x01(\v2\x1d.idp.kafka.v1.KafkaTopicShareR\x05share\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"W\n" +
	"\x19ApproveTopicAccessRequest\x12\x19\n" +
	"\bshare_id\x18\x01 \x01(\tR\ashareId\x12\x1f\n" +
	"\vapproved_by\x18\x02 \x01(\tR\n" +
	"approvedBy\"g\n" +
	"\x1aApproveTopicAccessResponse\x123\n" +
	"\x05share\x18\x01 \x01(\v2\x1d.idp.kafka.v1.KafkaTopicShareR\x05share\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"5\n" +
	"\x18RevokeTopicAccessRequest\x12\x19\n" +
	"\bshare_id\x18\x01 \x01(\tR\ashareId\"K\n" +
	"\x19RevokeTopicAccessResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x89\x01\n" +
	"\x16ListTopicSharesRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12!\n" +
	"\fworkspace_id\x18\x02 \x01(\tR\vworkspaceId\x121\n" +
	"\x06status\x18\x03 \x01(\x0e2\x19.idp.kafka.v1.ShareStatusR\x06status\"P\n" +
	"\x17ListTopicSharesResponse\x125\n" +
	"\x06shares\x18\x01 \x03(\v2\x1d.idp.kafka.v1.KafkaTopicShareR\x06shares\"\xf8\x01\n" +
	"\x15DiscoverTopicsRequest\x126\n" +
	"\x17requesting_workspace_id\x18\x01 \x01(\tR\x15requestingWorkspaceId\x12 \n" +
	"\venvironment\x18\x02 \x01(\tR\venvironment\x12\x16\n" +
	"\x06search\x18\x03 \x01(\tR\x06search\x12?\n" +
	"\rschema_format\x18\x04 \x01(\x0e2\x1a.idp.kafka.v1.SchemaFormatR\fschemaFormat\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x06 \x01(\x05R\x06offset\"g\n" +
	"\x16DiscoverTopicsResponse\x127\n" +
	"\x06topics\x18\x01 \x03(\v2\x1f.idp.kafka.v1.DiscoverableTopicR\x06topics\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xfa\x01\n" +
	"\x11DiscoverableTopic\x12.\n" +
	"\x05topic\x18\x01 \x01(\v2\x18.idp.kafka.v1.KafkaTopicR\x05topic\x122\n" +
	"\x15owning_workspace_name\x18\x02 \x01(\tR\x13owningWorkspaceName\x12=\n" +
	"\n" +
	"visibility\x18\x03 \x01(\x0e2\x1d.idp.kafka.v1.TopicVisibilityR\n" +
	"visibility\x12#\n" +
	"\raccess_status\x18\x04 \x01(\tR\faccessStatus\x12\x1d\n" +
	"\n" +
	"has_schema\x18\x05 \x01(\bR\thasSchema\"n\n" +
	"\x16GetTopicMetricsRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\x12\x1f\n" +
	"\vperiod_type\x18\x02 \x01(\tR\n" +
	"periodType\x12\x18\n" +
	"\aperiods\x18\x03 \x01(\x05R\aperiods\"T\n" +
	"\x17GetTopicMetricsResponse\x129\n" +
	"\ametrics\x18\x01 \x03(\v2\x1f.idp.kafka.v1.KafkaUsageMetricsR\ametrics\"3\n" +
	"\x16GetTopicLineageRequest\x12\x19\n" +
	"\btopic_id\x18\x01 \x01(\tR\atopicId\"\x8b\x01\n" +
	"\x17GetTopicLineageResponse\x127\n" +
	"\tproducers\x18\x01 \x03(\v2\x19.idp.kafka.v1.LineageNodeR\tproducers\x127\n" +
	"\tconsumers\x18\x02 \x03(\v2\x19.idp.kafka.v1.LineageNodeR\tconsumers\"\xba\x02\n" +
	"\vLineageNode\x12!\n" +
	"\fworkspace_id\x18\x01 \x01(\tR\vworkspaceId\x12%\n" +
	"\x0eworkspace_name\x18\x02 \x01(\tR\rworkspaceName\x12,\n" +
	"\x12service_account_id\x18\x03 \x01(\tR\x10serviceAccountId\x120\n" +
	"\x14service_account_name\x18\x04 \x01(\tR\x12serviceAccountName\x12\x1b\n" +
	"\tclient_id\x18\x05 \x01(\tR\bclientId\x12+\n" +
	"\x11bytes_transferred\x18\x06 \x01(\x03R\x10bytesTransferred\x127\n" +
	"\tlast_seen\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen*\xc0\x01\n" +
	"\fProviderType\x12\x1d\n" +
	"\x19PROVIDER_TYPE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aPROVIDER_TYPE_APACHE_KAFKA\x10\x01\x12!\n" +
	"\x1dPROVIDER_TYPE_CONFLUENT_CLOUD\x10\x02\x12\x19\n" +
	"\x15PROVIDER_TYPE_AWS_MSK\x10\x03\x12\x1a\n" +
	"\x16PROVIDER_TYPE_REDPANDA\x10\x04\x12\x17\n" +
	"\x13PROVIDER_TYPE_AIVEN\x10\x05*\xb7\x01\n" +
	"\x17ClusterValidationStatus\x12)\n" +
	"%CLUSTER_VALIDATION_STATUS_UNSPECIFIED\x10\x00\x12%\n" +
	"!CLUSTER_VALIDATION_STATUS_PENDING\x10\x01\x12#\n" +
	"\x1fCLUSTER_VALIDATION_STATUS_VALID\x10\x02\x12%\n" +
	"!CLUSTER_VALIDATION_STATUS_INVALID\x10\x03*\xba\x01\n" +
	"\vTopicStatus\x12\x1c\n" +
	"\x18TOPIC_STATUS_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dTOPIC_STATUS_PENDING_APPROVAL\x10\x01\x12\x1d\n" +
	"\x19TOPIC_STATUS_PROVISIONING\x10\x02\x12\x17\n" +
	"\x13TOPIC_STATUS_ACTIVE\x10\x03\x12\x17\n" +
	"\x13TOPIC_STATUS_FAILED\x10\x04\x12\x19\n" +
	"\x15TOPIC_STATUS_DELETING\x10\x05*y\n" +
	"\fSchemaFormat\x12\x1d\n" +
	"\x19SCHEMA_FORMAT_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12SCHEMA_FORMAT_AVRO\x10\x01\x12\x1a\n" +
	"\x16SCHEMA_FORMAT_PROTOBUF\x10\x02\x12\x16\n" +
	"\x12SCHEMA_FORMAT_JSON\x10\x03*\xbe\x01\n" +
	"\x13SchemaCompatibility\x12$\n" +
	" SCHEMA_COMPATIBILITY_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dSCHEMA_COMPATIBILITY_BACKWARD\x10\x01\x12 \n" +
	"\x1cSCHEMA_COMPATIBILITY_FORWARD\x10\x02\x12\x1d\n" +
	"\x19SCHEMA_COMPATIBILITY_FULL\x10\x03\x12\x1d\n" +
	"\x19SCHEMA_COMPATIBILITY_NONE\x10\x04*\xcc\x01\n" +
	"\x12ServiceAccountType\x12$\n" +
	" SERVICE_ACCOUNT_TYPE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dSERVICE_ACCOUNT_TYPE_PRODUCER\x10\x01\x12!\n" +
	"\x1dSERVICE_ACCOUNT_TYPE_CONSUMER\x10\x02\x12*\n" +
	"&SERVICE_ACCOUNT_TYPE_PRODUCER_CONSUMER\x10\x03\x12\x1e\n" +
	"\x1aSERVICE_ACCOUNT_TYPE_ADMIN\x10\x04*\x9d\x01\n" +
	"\vShareStatus\x12\x1c\n" +
	"\x18SHARE_STATUS_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cSHARE_STATUS_PENDING_REQUEST\x10\x01\x12\x19\n" +
	"\x15SHARE_STATUS_APPROVED\x10\x02\x12\x19\n" +
	"\x15SHARE_STATUS_REJECTED\x10\x03\x12\x18\n" +
	"\x14SHARE_STATUS_REVOKED\x10\x04*\x8b\x01\n" +
	"\x0fSharePermission\x12 \n" +
	"\x1cSHARE_PERMISSION_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15SHARE_PERMISSION_READ\x10\x01\x12\x1a\n" +
	"\x16SHARE_PERMISSION_WRITE\x10\x02\x12\x1f\n" +
	"\x1bSHARE_PERMISSION_READ_WRITE\x10\x03*\x91\x01\n" +
	"\x0fTopicVisibility\x12 \n" +
	"\x1cTOPIC_VISIBILITY_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18TOPIC_VISIBILITY_PRIVATE\x10\x01\x12!\n" +
	"\x1dTOPIC_VISIBILITY_DISCOVERABLE\x10\x02\x12\x1b\n" +
	"\x17TOPIC_VISIBILITY_PUBLIC\x10\x03*b\n" +
	"\vPolicyScope\x12\x1c\n" +
	"\x18POLICY_SCOPE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15POLICY_SCOPE_PLATFORM\x10\x01\x12\x1a\n" +
	"\x16POLICY_SCOPE_WORKSPACE\x10\x02*\xa6\x01\n" +
	"\x10SharePolicyScope\x12\"\n" +
	"\x1eSHARE_POLICY_SCOPE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dSHARE_POLICY_SCOPE_ALL_TOPICS\x10\x01\x12$\n" +
	" SHARE_POLICY_SCOPE_TOPIC_PATTERN\x10\x02\x12%\n" +
	"!SHARE_POLICY_SCOPE_SPECIFIC_TOPIC\x10\x032\xaf\x15\n" +
	"\fKafkaService\x12X\n" +
	"\rListProviders\x12\".idp.kafka.v1.ListProvidersRequest\x1a#.idp.kafka.v1.ListProvidersResponse\x12^\n" +
	"\x0fRegisterCluster\x12$.idp.kafka.v1.RegisterClusterRequest\x1a%.idp.kafka.v1.RegisterClusterResponse\x12^\n" +
	"\x0fValidateCluster\x12$.idp.kafka.v1.ValidateClusterRequest\x1a%.idp.kafka.v1.ValidateClusterResponse\x12U\n" +
	"\fListClusters\x12!.idp.kafka.v1.ListClustersRequest\x1a\".idp.kafka.v1.ListClustersResponse\x12X\n" +
	"\rDeleteCluster\x12\".idp.kafka.v1.DeleteClusterRequest\x1a#.idp.kafka.v1.DeleteClusterResponse\x12y\n" +
	"\x18CreateEnvironmentMapping\x12-.idp.kafka.v1.CreateEnvironmentMappingRequest\x1a..idp.kafka.v1.CreateEnvironmentMappingResponse\x12v\n" +
	"\x17ListEnvironmentMappings\x12,.idp.kafka.v1.ListEnvironmentMappingsRequest\x1a-.idp.kafka.v1.ListEnvironmentMappingsResponse\x12y\n" +
	"\x18DeleteEnvironmentMapping\x12-.idp.kafka.v1.DeleteEnvironmentMappingRequest\x1a..idp.kafka.v1.DeleteEnvironmentMappingResponse\x12R\n" +
	"\vCreateTopic\x12 .idp.kafka.v1.CreateTopicRequest\x1a!.idp.kafka.v1.CreateTopicResponse\x12I\n" +
	"\bGetTopic\x12\x1d.idp.kafka.v1.GetTopicRequest\x1a\x1e.idp.kafka.v1.GetTopicResponse\x12O\n" +
	"\n" +
	"ListTopics\x12\x1f.idp.kafka.v1.ListTopicsRequest\x1a .idp.kafka.v1.ListTopicsResponse\x12R\n" +
	"\vUpdateTopic\x12 .idp.kafka.v1.UpdateTopicRequest\x1a!.idp.kafka.v1.UpdateTopicResponse\x12R\n" +
	"\vDeleteTopic\x12 .idp.kafka.v1.DeleteTopicRequest\x1a!.idp.kafka.v1.DeleteTopicResponse\x12U\n" +
	"\fApproveTopic\x12!.idp.kafka.v1.ApproveTopicRequest\x1a\".idp.kafka.v1.ApproveTopicResponse\x12[\n" +
	"\x0eRegisterSchema\x12#.idp.kafka.v1.RegisterSchemaRequest\x1a$.idp.kafka.v1.RegisterSchemaResponse\x12L\n" +
	"\tGetSchema\x12\x1e.idp.kafka.v1.GetSchemaRequest\x1a\x1f.idp.kafka.v1.GetSchemaResponse\x12R\n" +
	"\vListSchemas\x12 .idp.kafka.v1.ListSchemasRequest\x1a!.idp.kafka.v1.ListSchemasResponse\x12y\n" +
	"\x18CheckSchemaCompatibility\x12-.idp.kafka.v1.CheckSchemaCompatibilityRequest\x1a..idp.kafka.v1.CheckSchemaCompatibilityResponse\x12m\n" +
	"\x14CreateServiceAccount\x12).idp.kafka.v1.CreateServiceAccountRequest\x1a*.idp.kafka.v1.CreateServiceAccountResponse\x12j\n" +
	"\x13ListServiceAccounts\x12(.idp.kafka.v1.ListServiceAccountsRequest\x1a).idp.kafka.v1.ListServiceAccountsResponse\x12m\n" +
	"\x14RevokeServiceAccount\x12).idp.kafka.v1.RevokeServiceAccountRequest\x1a*.idp.kafka.v1.RevokeServiceAccountResponse\x12g\n" +
	"\x12RequestTopicAccess\x12'.idp.kafka.v1.RequestTopicAccessRequest\x1a(.idp.kafka.v1.RequestTopicAccessResponse\x12g\n" +
	"\x12ApproveTopicAccess\x12'.idp.kafka.v1.ApproveTopicAccessRequest\x1a(.idp.kafka.v1.ApproveTopicAccessResponse\x12d\n" +
	"\x11RevokeTopicAccess\x12&.idp.kafka.v1.RevokeTopicAccessRequest\x1a'.idp.kafka.v1.RevokeTopicAccessResponse\x12^\n" +
	"\x0fListTopicShares\x12$.idp.kafka.v1.ListTopicSharesRequest\x1a%.idp.kafka.v1.ListTopicSharesResponse\x12[\n" +
	"\x0eDiscoverTopics\x12#.idp.kafka.v1.DiscoverTopicsRequest\x1a$.idp.kafka.v1.DiscoverTopicsResponse\x12^\n" +
	"\x0fGetTopicMetrics\x12$.idp.kafka.v1.GetTopicMetricsRequest\x1a%.idp.kafka.v1.GetTopicMetricsResponse\x12^\n" +
	"\x0fGetTopicLineage\x12$.idp.kafka.v1.GetTopicLineageRequest\x1a%.idp.kafka.v1.GetTopicLineageResponseB@Z>github.com/drewpayment/orbit/proto/gen/go/idp/kafka/v1;kafkav1b\x06proto3"

var (
	file_idp_kafka_v1_kafka_proto_rawDescOnce sync.Once
	file_idp_kafka_v1_kafka_proto_rawDescData []byte
)

func file_idp_kafka_v1_kafka_proto_rawDescGZIP() []byte {
	file_idp_kafka_v1_kafka_proto_rawDescOnce.Do(func() {
		file_idp_kafka_v1_kafka_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_idp_kafka_v1_kafka_proto_rawDesc), len(file_idp_kafka_v1_kafka_proto_rawDesc)))
	})
	return file_idp_kafka_v1_kafka_proto_rawDescData
}

var file_idp_kafka_v1_kafka_proto_enumTypes = make([]protoimpl.EnumInfo, 11)
var file_idp_kafka_v1_kafka_proto_msgTypes = make([]protoimpl.MessageInfo, 84)
var file_idp_kafka_v1_kafka_proto_goTypes = []any{
	(ProviderType)(0),                        // 0: idp.kafka.v1.ProviderType
	(ClusterValidationStatus)(0),             // 1: idp.kafka.v1.ClusterValidationStatus
	(TopicStatus)(0),                         // 2: idp.kafka.v1.TopicStatus
	(SchemaFormat)(0),                        // 3: idp.kafka.v1.SchemaFormat
	(SchemaCompatibility)(0),                 // 4: idp.kafka.v1.SchemaCompatibility
	(ServiceAccountType)(0),                  // 5: idp.kafka.v1.ServiceAccountType
	(ShareStatus)(0),                         // 6: idp.kafka.v1.ShareStatus
	(SharePermission)(0),                     // 7: idp.kafka.v1.SharePermission
	(TopicVisibility)(0),                     // 8: idp.kafka.v1.TopicVisibility
	(PolicyScope)(0),                         // 9: idp.kafka.v1.PolicyScope
	(SharePolicyScope)(0),                    // 10: idp.kafka.v1.SharePolicyScope
	(*KafkaProvider)(nil),                    // 11: idp.kafka.v1.KafkaProvider
	(*ProviderCapabilities)(nil),             // 12: idp.kafka.v1.ProviderCapabilities
	(*KafkaCluster)(nil),                     // 13: idp.kafka.v1.KafkaCluster
	(*KafkaEnvironmentMapping)(nil),          // 14: idp.kafka.v1.KafkaEnvironmentMapping
	(*SchemaRegistry)(nil),                   // 15: idp.kafka.v1.SchemaRegistry
	(*EnvironmentCompatibilityOverride)(nil), // 16: idp.kafka.v1.EnvironmentCompatibilityOverride
	(*KafkaTopic)(nil),                       // 17: idp.kafka.v1.KafkaTopic
	(*KafkaSchema)(nil),                      // 18: idp.kafka.v1.KafkaSchema
	(*KafkaServiceAccount)(nil),              // 19: idp.kafka.v1.KafkaServiceAccount
	(*KafkaTopicShare)(nil),                  // 20: idp.kafka.v1.KafkaTopicShare
	(*KafkaTopicPolicy)(nil),                 // 21: idp.kafka.v1.KafkaTopicPolicy
	(*PartitionLimits)(nil),                  // 22: idp.kafka.v1.PartitionLimits
	(*RetentionLimits)(nil),                  // 23: idp.kafka.v1.RetentionLimits
	(*KafkaTopicSharePolicy)(nil),            // 24: idp.kafka.v1.KafkaTopicSharePolicy
	(*AutoApproveConfig)(nil),                // 25: idp.kafka.v1.AutoApproveConfig
	(*KafkaUsageMetrics)(nil),                // 26: idp.kafka.v1.KafkaUsageMetrics
	(*KafkaConsumerGroup)(nil),               // 27: idp.kafka.v1.KafkaConsumerGroup
	(*KafkaClientActivity)(nil),              // 28: idp.kafka.v1.KafkaClientActivity
	(*ListProvidersRequest)(nil),             // 29: idp.kafka.v1.ListProvidersRequest
	(*ListProvidersResponse)(nil),            // 30: idp.kafka.v1.ListProvidersResponse
	(*RegisterClusterRequest)(nil),           // 31: idp.kafka.v1.RegisterClusterRequest
	(*RegisterClusterResponse)(nil),          // 32: idp.kafka.v1.RegisterClusterResponse
	(*ValidateClusterRequest)(nil),           // 33: idp.kafka.v1.ValidateClusterRequest
	(*ValidateClusterResponse)(nil),          // 34: idp.kafka.v1.ValidateClusterResponse
	(*ListClustersRequest)(nil),              // 35: idp.kafka.v1.ListClustersRequest
	(*ListClustersResponse)(nil),             // 36: idp.kafka.v1.ListClustersResponse
	(*DeleteClusterRequest)(nil),             // 37: idp.kafka.v1.DeleteClusterRequest
	(*DeleteClusterResponse)(nil),            // 38: idp.kafka.v1.DeleteClusterResponse
	(*CreateEnvironmentMappingRequest)(nil),  // 39: idp.kafka.v1.CreateEnvironmentMappingRequest
	(*CreateEnvironmentMappingResponse)(nil), // 40: idp.kafka.v1.CreateEnvironmentMappingResponse
	(*ListEnvironmentMappingsRequest)(nil),   // 41: idp.kafka.v1.ListEnvironmentMappingsRequest
	(*ListEnvironmentMappingsResponse)(nil),  // 42: idp.kafka.v1.ListEnvironmentMappingsResponse
	(*DeleteEnvironmentMappingRequest)(nil),  // 43: idp.kafka.v1.DeleteEnvironmentMappingRequest
	(*DeleteEnvironmentMappingResponse)(nil), // 44: idp.kafka.v1.DeleteEnvironmentMappingResponse
	(*CreateTopicRequest)(nil),               // 45: idp.kafka.v1.CreateTopicRequest
	(*CreateTopicResponse)(nil),              // 46: idp.kafka.v1.CreateTopicResponse
	(*GetTopicRequest)(nil),                  // 47: idp.kafka.v1.GetTopicRequest
	(*GetTopicResponse)(nil),                 // 48: idp.kafka.v1.GetTopicResponse
	(*ListTopicsRequest)(nil),                // 49: idp.kafka.v1.ListTopicsRequest
	(*ListTopicsResponse)(nil),               // 50: idp.kafka.v1.ListTopicsResponse
	(*UpdateTopicRequest)(nil),               // 51: idp.kafka.v1.UpdateTopicRequest
	(*UpdateTopicResponse)(nil),              // 52: idp.kafka.v1.UpdateTopicResponse
	(*DeleteTopicRequest)(nil),               // 53: idp.kafka.v1.DeleteTopicRequest
	(*DeleteTopicResponse)(nil),              // 54: idp.kafka.v1.DeleteTopicResponse
	(*ApproveTopicRequest)(nil),              // 55: idp.kafka.v1.ApproveTopicRequest
	(*ApproveTopicResponse)(nil),             // 56: idp.kafka.v1.ApproveTopicResponse
	(*RegisterSchemaRequest)(nil),            // 57: idp.kafka.v1.RegisterSchemaRequest
	(*RegisterSchemaResponse)(nil),           // 58: idp.kafka.v1.RegisterSchemaResponse
	(*GetSchemaRequest)(nil),                 // 59: idp.kafka.v1.GetSchemaRequest
	(*GetSchemaResponse)(nil),                // 60: idp.kafka.v1.GetSchemaResponse
	(*ListSchemasRequest)(nil),               // 61: idp.kafka.v1.ListSchemasRequest
	(*ListSchemasResponse)(nil),              // 62: idp.kafka.v1.ListSchemasResponse
	(*CheckSchemaCompatibilityRequest)(nil),  // 63: idp.kafka.v1.CheckSchemaCompatibilityRequest
	(*CheckSchemaCompatibilityResponse)(nil), // 64: idp.kafka.v1.CheckSchemaCompatibilityResponse
	(*CreateServiceAccountRequest)(nil),      // 65: idp.kafka.v1.CreateServiceAccountRequest
	(*CreateServiceAccountResponse)(nil),     // 66: idp.kafka.v1.CreateServiceAccountResponse
	(*ListServiceAccountsRequest)(nil),       // 67: idp.kafka.v1.ListServiceAccountsRequest
	(*ListServiceAccountsResponse)(nil),      // 68: idp.kafka.v1.ListServiceAccountsResponse
	(*RevokeServiceAccountRequest)(nil),      // 69: idp.kafka.v1.RevokeServiceAccountRequest
	(*RevokeServiceAccountResponse)(nil),     // 70: idp.kafka.v1.RevokeServiceAccountResponse
	(*RequestTopicAccessRequest)(nil),        // 71: idp.kafka.v1.RequestTopicAccessRequest
	(*RequestTopicAccessResponse)(nil),       // 72: idp.kafka.v1.RequestTopicAccessResponse
	(*ApproveTopicAccessRequest)(nil),        // 73: idp.kafka.v1.ApproveTopicAccessRequest
	(*ApproveTopicAccessResponse)(nil),       // 74: idp.kafka.v1.ApproveTopicAccessResponse
	(*RevokeTopicAccessRequest)(nil),         // 75: idp.kafka.v1.RevokeTopicAccessRequest
	(*RevokeTopicAccessResponse)(nil),        // 76: idp.kafka.v1.RevokeTopicAccessResponse
	(*ListTopicSharesRequest)(nil),           // 77: idp.kafka.v1.ListTopicSharesRequest
	(*ListTopicSharesResponse)(nil),          // 78: idp.kafka.v1.ListTopicSharesResponse
	(*DiscoverTopicsRequest)(nil),            // 79: idp.kafka.v1.DiscoverTopicsRequest
	(*DiscoverTopicsResponse)(nil),           // 80: idp.kafka.v1.DiscoverTopicsResponse
	(*DiscoverableTopic)(nil),                // 81: idp.kafka.v1.DiscoverableTopic
	(*GetTopicMetricsRequest)(nil),           // 82: idp.kafka.v1.GetTopicMetricsRequest
	(*GetTopicMetricsResponse)(nil),          // 83: idp.kafka.v1.GetTopicMetricsResponse
	(*GetTopicLineageRequest)(nil),           // 84: idp.kafka.v1.GetTopicLineageRequest
	(*GetTopicLineageResponse)(nil),          // 85: idp.kafka.v1.GetTopicLineageResponse
	(*LineageNode)(nil),                      // 86: idp.kafka.v1.LineageNode
	nil,                                      // 87: idp.kafka.v1.KafkaCluster.ConnectionConfigEntry
	nil,                                      // 88: idp.kafka.v1.KafkaEnvironmentMapping.RoutingRuleEntry
	nil,                                      // 89: idp.kafka.v1.KafkaTopic.ConfigEntry
	nil,                                      // 90: idp.kafka.v1.RegisterClusterRequest.ConnectionConfigEntry
	nil,                                      // 91: idp.kafka.v1.RegisterClusterRequest.CredentialsEntry
	nil,                                      // 92: idp.kafka.v1.CreateEnvironmentMappingRequest.RoutingRuleEntry
	nil,                                      // 93: idp.kafka.v1.CreateTopicRequest.ConfigEntry
	nil,                                      // 94: idp.kafka.v1.UpdateTopicRequest.ConfigEntry
	(*timestamppb.Timestamp)(nil),            // 95: google.protobuf.Timestamp
}
var file_idp_kafka_v1_kafka_proto_depIdxs = []int32{
	12,  // 0: idp.kafka.v1.KafkaProvider.capabilities:type_name -> idp.kafka.v1.ProviderCapabilities
	87,  // 1: idp.kafka.v1.KafkaCluster.connection_config:type_name -> idp.kafka.v1.KafkaCluster.ConnectionConfigEntry
	1,   // 2: idp.kafka.v1.KafkaCluster.validation_status:type_name -> idp.kafka.v1.ClusterValidationStatus
	95,  // 3: idp.kafka.v1.KafkaCluster.last_validated_at:type_name -> google.protobuf.Timestamp
	95,  // 4: idp.kafka.v1.KafkaCluster.created_at:type_name -> google.protobuf.Timestamp
	95,  // 5: idp.kafka.v1.KafkaCluster.updated_at:type_name -> google.protobuf.Timestamp
	88,  // 6: idp.kafka.v1.KafkaEnvironmentMapping.routing_rule:type_name -> idp.kafka.v1.KafkaEnvironmentMapping.RoutingRuleEntry
	4,   // 7: idp.kafka.v1.SchemaRegistry.default_compatibility:type_name -> idp.kafka.v1.SchemaCompatibility
	16,  // 8: idp.kafka.v1.SchemaRegistry.environment_overrides:type_name -> idp.kafka.v1.EnvironmentCompatibilityOverride
	4,   // 9: idp.kafka.v1.EnvironmentCompatibilityOverride.compatibility:type_name -> idp.kafka.v1.SchemaCompatibility
	89,  // 10: idp.kafka.v1.KafkaTopic.config:type_name -> idp.kafka.v1.KafkaTopic.ConfigEntry
	2,   // 11: idp.kafka.v1.KafkaTopic.status:type_name -> idp.kafka.v1.TopicStatus
	95,  // 12: idp.kafka.v1.KafkaTopic.approved_at:type_name -> google.protobuf.Timestamp
	95,  // 13: idp.kafka.v1.KafkaTopic.created_at:type_name -> google.protobuf.Timestamp
	95,  // 14: idp.kafka.v1.KafkaTopic.updated_at:type_name -> google.protobuf.Timestamp
	3,   // 15: idp.kafka.v1.KafkaSchema.format:type_name -> idp.kafka.v1.SchemaFormat
	4,   // 16: idp.kafka.v1.KafkaSchema.compatibility:type_name -> idp.kafka.v1.SchemaCompatibility
	95,  // 17: idp.kafka.v1.KafkaSchema.created_at:type_name -> google.protobuf.Timestamp
	95,  // 18: idp.kafka.v1.KafkaSchema.updated_at:type_name -> google.protobuf.Timestamp
	5,   // 19: idp.kafka.v1.KafkaServiceAccount.type:type_name -> idp.kafka.v1.ServiceAccountType
	95,  // 20: idp.kafka.v1.KafkaServiceAccount.created_at:type_name -> google.protobuf.Timestamp
	7,   // 21: idp.kafka.v1.KafkaTopicShare.permission:type_name -> idp.kafka.v1.SharePermission
	6,   // 22: idp.kafka.v1.KafkaTopicShare.status:type_name -> idp.kafka.v1.ShareStatus
	95,  // 23: idp.kafka.v1.KafkaTopicShare.requested_at:type_name -> google.protobuf.Timestamp
	95,  // 24: idp.kafka.v1.KafkaTopicShare.approved_at:type_name -> google.protobuf.Timestamp
	95,  // 25: idp.kafka.v1.KafkaTopicShare.expires_at:type_name -> google.protobuf.Timestamp
	9,   // 26: idp.kafka.v1.KafkaTopicPolicy.scope:type_name -> idp.kafka.v1.PolicyScope
	22,  // 27: idp.kafka.v1.KafkaTopicPolicy.partition_limits:type_name -> idp.kafka.v1.PartitionLimits
	23,  // 28: idp.kafka.v1.KafkaTopicPolicy.retention_limits:type_name -> idp.kafka.v1.RetentionLimits
	10,  // 29: idp.kafka.v1.KafkaTopicSharePolicy.scope:type_name -> idp.kafka.v1.SharePolicyScope
	8,   // 30: idp.kafka.v1.KafkaTopicSharePolicy.visibility:type_name -> idp.kafka.v1.TopicVisibility
	25,  // 31: idp.kafka.v1.KafkaTopicSharePolicy.auto_approve:type_name -> idp.kafka.v1.AutoApproveConfig
	7,   // 32: idp.kafka.v1.KafkaTopicSharePolicy.default_permission:type_name -> idp.kafka.v1.SharePermission
	7,   // 33: idp.kafka.v1.AutoApproveConfig.permissions:type_name -> idp.kafka.v1.SharePermission
	95,  // 34: idp.kafka.v1.KafkaConsumerGroup.last_seen:type_name -> google.protobuf.Timestamp
	95,  // 35: idp.kafka.v1.KafkaConsumerGroup.last_updated:type_name -> google.protobuf.Timestamp
	95,  // 36: idp.kafka.v1.KafkaClientActivity.last_seen:type_name -> google.protobuf.Timestamp
	11,  // 37: idp.kafka.v1.ListProvidersResponse.providers:type_name -> idp.kafka.v1.KafkaProvider
	90,  // 38: idp.kafka.v1.RegisterClusterRequest.connection_config:type_name -> idp.kafka.v1.RegisterClusterRequest.ConnectionConfigEntry
	91,  // 39: idp.kafka.v1.RegisterClusterRequest.credentials:type_name -> idp.kafka.v1.RegisterClusterRequest.CredentialsEntry
	13,  // 40: idp.kafka.v1.RegisterClusterResponse.cluster:type_name -> idp.kafka.v1.KafkaCluster
	13,  // 41: idp.kafka.v1.ListClustersResponse.clusters:type_name -> idp.kafka.v1.KafkaCluster
	92,  // 42: idp.kafka.v1.CreateEnvironmentMappingRequest.routing_rule:type_name -> idp.kafka.v1.CreateEnvironmentMappingRequest.RoutingRuleEntry
	14,  // 43: idp.kafka.v1.CreateEnvironmentMappingResponse.mapping:type_name -> idp.kafka.v1.KafkaEnvironmentMapping
	14,  // 44: idp.kafka.v1.ListEnvironmentMappingsResponse.mappings:type_name -> idp.kafka.v1.KafkaEnvironmentMapping
	93,  // 45: idp.kafka.v1.CreateTopicRequest.config:type_name -> idp.kafka.v1.CreateTopicRequest.ConfigEntry
	18,  // 46: idp.kafka.v1.CreateTopicRequest.schema:type_name -> idp.kafka.v1.KafkaSchema
	17,  // 47: idp.kafka.v1.CreateTopicResponse.topic:type_name -> idp.kafka.v1.KafkaTopic
	17,  // 48: idp.kafka.v1.GetTopicResponse.topic:type_name -> idp.kafka.v1.KafkaTopic
	2,   // 49: idp.kafka.v1.ListTopicsRequest.status:type_name -> idp.kafka.v1.TopicStatus
	17,  // 50: idp.kafka.v1.ListTopicsResponse.topics:type_name -> idp.kafka.v1.KafkaTopic
	94,  // 51: idp.kafka.v1.UpdateTopicRequest.config:type_name -> idp.kafka.v1.UpdateTopicRequest.ConfigEntry
	17,  // 52: idp.kafka.v1.UpdateTopicResponse.topic:type_name -> idp.kafka.v1.KafkaTopic
	17,  // 53: idp.kafka.v1.ApproveTopicResponse.topic:type_name -> idp.kafka.v1.KafkaTopic
	3,   // 54: idp.kafka.v1.RegisterSchemaRequest.format:type_name -> idp.kafka.v1.SchemaFormat
	4,   // 55: idp.kafka.v1.RegisterSchemaRequest.compatibility:type_name -> idp.kafka.v1.SchemaCompatibility
	18,  // 56: idp.kafka.v1.RegisterSchemaResponse.schema:type_name -> idp.kafka.v1.KafkaSchema
	18,  // 57: idp.kafka.v1.GetSchemaResponse.schema:type_name -> idp.kafka.v1.KafkaSchema
	18,  // 58: idp.kafka.v1.ListSchemasResponse.schemas:type_name -> idp.kafka.v1.KafkaSchema
	3,   // 59: idp.kafka.v1.CheckSchemaCompatibilityRequest.format:type_name -> idp.kafka.v1.SchemaFormat
	5,   // 60: idp.kafka.v1.CreateServiceAccountRequest.type:type_name -> idp.kafka.v1.ServiceAccountType
	19,  // 61: idp.kafka.v1.CreateServiceAccountResponse.service_account:type_name -> idp.kafka.v1.KafkaServiceAccount
	19,  // 62: idp.kafka.v1.ListServiceAccountsResponse.service_accounts:type_name -> idp.kafka.v1.KafkaServiceAccount
	7,   // 63: idp.kafka.v1.RequestTopicAccessRequest.permission:type_name -> idp.kafka.v1.SharePermission
	20,  // 64: idp.kafka.v1.RequestTopicAccessResponse.share:type_name -> idp.kafka.v1.KafkaTopicShare
	20,  // 65: idp.kafka.v1.ApproveTopicAccessResponse.share:type_name -> idp.kafka.v1.KafkaTopicShare
	6,   // 66: idp.kafka.v1.ListTopicSharesRequest.status:type_name -> idp.kafka.v1.ShareStatus
	20,  // 67: idp.kafka.v1.ListTopicSharesResponse.shares:type_name -> idp.kafka.v1.KafkaTopicShare
	3,   // 68: idp.kafka.v1.DiscoverTopicsRequest.schema_format:type_name -> idp.kafka.v1.SchemaFormat
	81,  // 69: idp.kafka.v1.DiscoverTopicsResponse.topics:type_name -> idp.kafka.v1.DiscoverableTopic
	17,  // 70: idp.kafka.v1.DiscoverableTopic.topic:type_name -> idp.kafka.v1.KafkaTopic
	8,   // 71: idp.kafka.v1.DiscoverableTopic.visibility:type_name -> idp.kafka.v1.TopicVisibility
	26,  // 72: idp.kafka.v1.GetTopicMetricsResponse.metrics:type_name -> idp.kafka.v1.KafkaUsageMetrics
	86,  // 73: idp.kafka.v1.GetTopicLineageResponse.producers:type_name -> idp.kafka.v1.LineageNode
	86,  // 74: idp.kafka.v1.GetTopicLineageResponse.consumers:type_name -> idp.kafka.v1.LineageNode
	95,  // 75: idp.kafka.v1.LineageNode.last_seen:type_name -> google.protobuf.Timestamp
	29,  // 76: idp.kafka.v1.KafkaService.ListProviders:input_type -> idp.kafka.v1.ListProvidersRequest
	31,  // 77: idp.kafka.v1.KafkaService.RegisterCluster:input_type -> idp.kafka.v1.RegisterClusterRequest
	33,  // 78: idp.kafka.v1.KafkaService.ValidateCluster:input_type -> idp.kafka.v1.ValidateClusterRequest
	35,  // 79: idp.kafka.v1.KafkaService.ListClusters:input_type -> idp.kafka.v1.ListClustersRequest
	37,  // 80: idp.kafka.v1.KafkaService.DeleteCluster:input_type -> idp.kafka.v1.DeleteClusterRequest
	39,  // 81: idp.kafka.v1.KafkaService.CreateEnvironmentMapping:input_type -> idp.kafka.v1.CreateEnvironmentMappingRequest
	41,  // 82: idp.kafka.v1.KafkaService.ListEnvironmentMappings:input_type -> idp.kafka.v1.ListEnvironmentMappingsRequest
	43,  // 83: idp.kafka.v1.KafkaService.DeleteEnvironmentMapping:input_type -> idp.kafka.v1.DeleteEnvironmentMappingRequest
	45,  // 84: idp.kafka.v1.KafkaService.CreateTopic:input_type -> idp.kafka.v1.CreateTopicRequest
	47,  // 85: idp.kafka.v1.KafkaService.GetTopic:input_type -> idp.kafka.v1.GetTopicRequest
	49,  // 86: idp.kafka.v1.KafkaService.ListTopics:input_type -> idp.kafka.v1.ListTopicsRequest
	51,  // 87: idp.kafka.v1.KafkaService.UpdateTopic:input_type -> idp.kafka.v1.UpdateTopicRequest
	53,  // 88: idp.kafka.v1.KafkaService.DeleteTopic:input_type -> idp.kafka.v1.DeleteTopicRequest
	55,  // 89: idp.kafka.v1.KafkaService.ApproveTopic:input_type -> idp.kafka.v1.ApproveTopicRequest
	57,  // 90: idp.kafka.v1.KafkaService.RegisterSchema:input_type -> idp.kafka.v1.RegisterSchemaRequest
	59,  // 91: idp.kafka.v1.KafkaService.GetSchema:input_type -> idp.kafka.v1.GetSchemaRequest
	61,  // 92: idp.kafka.v1.KafkaService.ListSchemas:input_type -> idp.kafka.v1.ListSchemasRequest
	63,  // 93: idp.kafka.v1.KafkaService.CheckSchemaCompatibility:input_type -> idp.kafka.v1.CheckSchemaCompatibilityRequest
	65,  // 94: idp.kafka.v1.KafkaService.CreateServiceAccount:input_type -> idp.kafka.v1.CreateServiceAccountRequest
	67,  // 95: idp.kafka.v1.KafkaService.ListServiceAccounts:input_type -> idp.kafka.v1.ListServiceAccountsRequest
	69,  // 96: idp.kafka.v1.KafkaService.RevokeServiceAccount:input_type -> idp.kafka.v1.RevokeServiceAccountRequest
	71,  // 97: idp.kafka.v1.KafkaService.RequestTopicAccess:input_type -> idp.kafka.v1.RequestTopicAccessRequest
	73,  // 98: idp.kafka.v1.KafkaService.ApproveTopicAccess:input_type -> idp.kafka.v1.ApproveTopicAccessRequest
	75,  // 99: idp.kafka.v1.KafkaService.RevokeTopicAccess:input_type -> idp.kafka.v1.RevokeTopicAccessRequest
	77,  // 100: idp.kafka.v1.KafkaService.ListTopicShares:input_type -> idp.kafka.v1.ListTopicSharesRequest
	79,  // 101: idp.kafka.v1.KafkaService.DiscoverTopics:input_type -> idp.kafka.v1.DiscoverTopicsRequest
	82,  // 102: idp.kafka.v1.KafkaService.GetTopicMetrics:input_type -> idp.kafka.v1.GetTopicMetricsRequest
	84,  // 103: idp.kafka.v1.KafkaService.GetTopicLineage:input_type -> idp.kafka.v1.GetTopicLineageRequest
	30,  // 104: idp.kafka.v1.KafkaService.ListProviders:output_type -> idp.kafka.v1.ListProvidersResponse
	32,  // 105: idp.kafka.v1.KafkaService.RegisterCluster:output_type -> idp.kafka.v1.RegisterClusterResponse
	34,  // 106: idp.kafka.v1.KafkaService.ValidateCluster:output_type -> idp.kafka.v1.ValidateClusterResponse
	36,  // 107: idp.kafka.v1.KafkaService.ListClusters:output_type -> idp.kafka.v1.ListClustersResponse
	38,  // 108: idp.kafka.v1.KafkaService.DeleteCluster:output_type -> idp.kafka.v1.DeleteClusterResponse
	40,  // 109: idp.kafka.v1.KafkaService.CreateEnvironmentMapping:output_type -> idp.kafka.v1.CreateEnvironmentMappingResponse
	42,  // 110: idp.kafka.v1.KafkaService.ListEnvironmentMappings:output_type -> idp.kafka.v1.ListEnvironmentMappingsResponse
	44,  // 111: idp.kafka.v1.KafkaService.DeleteEnvironmentMapping:output_type -> idp.kafka.v1.DeleteEnvironmentMappingResponse
	46,  // 112: idp.kafka.v1.KafkaService.CreateTopic:output_type -> idp.kafka.v1.CreateTopicResponse
	48,  // 113: idp.kafka.v1.KafkaService.GetTopic:output_type -> idp.kafka.v1.GetTopicResponse
	50,  // 114: idp.kafka.v1.KafkaService.ListTopics:output_type -> idp.kafka.v1.ListTopicsResponse
	52,  // 115: idp.kafka.v1.KafkaService.UpdateTopic:output_type -> idp.kafka.v1.UpdateTopicResponse
	54,  // 116: idp.kafka.v1.KafkaService.DeleteTopic:output_type -> idp.kafka.v1.DeleteTopicResponse
	56,  // 117: idp.kafka.v1.KafkaService.ApproveTopic:output_type -> idp.kafka.v1.ApproveTopicResponse
	58,  // 118: idp.kafka.v1.KafkaService.RegisterSchema:output_type -> idp.kafka.v1.RegisterSchemaResponse
	60,  // 119: idp.kafka.v1.KafkaService.GetSchema:output_type -> idp.kafka.v1.GetSchemaResponse
	62,  // 120: idp.kafka.v1.KafkaService.ListSchemas:output_type -> idp.kafka.v1.ListSchemasResponse
	64,  // 121: idp.kafka.v1.KafkaService.CheckSchemaCompatibility:output_type -> idp.kafka.v1.CheckSchemaCompatibilityResponse
	66,  // 122: idp.kafka.v1.KafkaService.CreateServiceAccount:output_type -> idp.kafka.v1.CreateServiceAccountResponse
	68,  // 123: idp.kafka.v1.KafkaService.ListServiceAccounts:output_type -> idp.kafka.v1.ListServiceAccountsResponse
	70,  // 124: idp.kafka.v1.KafkaService.RevokeServiceAccount:output_type -> idp.kafka.v1.RevokeServiceAccountResponse
	72,  // 125: idp.kafka.v1.KafkaService.RequestTopicAccess:output_type -> idp.kafka.v1.RequestTopicAccessResponse
	74,  // 126: idp.kafka.v1.KafkaService.ApproveTopicAccess:output_type -> idp.kafka.v1.ApproveTopicAccessResponse
	76,  // 127: idp.kafka.v1.KafkaService.RevokeTopicAccess:output_type -> idp.kafka.v1.RevokeTopicAccessResponse
	78,  // 128: idp.kafka.v1.KafkaService.ListTopicShares:output_type -> idp.kafka.v1.ListTopicSharesResponse
	80,  // 129: idp.kafka.v1.KafkaService.DiscoverTopics:output_type -> idp.kafka.v1.DiscoverTopicsResponse
	83,  // 130: idp.kafka.v1.KafkaService.GetTopicMetrics:output_type -> idp.kafka.v1.GetTopicMetricsResponse
	85,  // 131: idp.kafka.v1.KafkaService.GetTopicLineage:output_type -> idp.kafka.v1.GetTopicLineageResponse
	104, // [104:132] is the sub-list for method output_type
	76,  // [76:104] is the sub-list for method input_type
	76,  // [76:76] is the sub-list for extension type_name
	76,  // [76:76] is the sub-list for extension extendee
	0,   // [0:76] is the sub-list for field type_name
}

func init() { file_idp_kafka_v1_kafka_proto_init() }
func file_idp_kafka_v1_kafka_proto_init() {
	if File_idp_kafka_v1_kafka_proto != nil {
		return
	}
	file_idp_kafka_v1_kafka_proto_msgTypes[40].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_idp_kafka_v1_kafka_proto_rawDesc), len(file_idp_kafka_v1_kafka_proto_rawDesc)),
			NumEnums:      11,
			NumMessages:   84,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_idp_kafka_v1_kafka_proto_goTypes,
		DependencyIndexes: file_idp_kafka_v1_kafka_proto_depIdxs,
		EnumInfos:         file_idp_kafka_v1_kafka_proto_enumTypes,
		MessageInfos:      file_idp_kafka_v1_kafka_proto_msgTypes,
	}.Build()
	File_idp_kafka_v1_kafka_proto = out.File
	file_idp_kafka_v1_kafka_proto_goTypes = nil
	file_idp_kafka_v1_kafka_proto_depIdxs = nil
}
