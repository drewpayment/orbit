// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: idp/kafka/v1/kafka.proto

package kafkav1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KafkaService_ListProviders_FullMethodName             = "/idp.kafka.v1.KafkaService/ListProviders"
	KafkaService_RegisterCluster_FullMethodName           = "/idp.kafka.v1.KafkaService/RegisterCluster"
	KafkaService_ValidateCluster_FullMethodName           = "/idp.kafka.v1.KafkaService/ValidateCluster"
	KafkaService_ValidateClusterConnection_FullMethodName = "/idp.kafka.v1.KafkaService/ValidateClusterConnection"
	KafkaService_ListClusters_FullMethodName              = "/idp.kafka.v1.KafkaService/ListClusters"
	KafkaService_DeleteCluster_FullMethodName             = "/idp.kafka.v1.KafkaService/DeleteCluster"
	KafkaService_CreateEnvironmentMapping_FullMethodName  = "/idp.kafka.v1.KafkaService/CreateEnvironmentMapping"
	KafkaService_ListEnvironmentMappings_FullMethodName   = "/idp.kafka.v1.KafkaService/ListEnvironmentMappings"
	KafkaService_DeleteEnvironmentMapping_FullMethodName  = "/idp.kafka.v1.KafkaService/DeleteEnvironmentMapping"
	KafkaService_CreateTopic_FullMethodName               = "/idp.kafka.v1.KafkaService/CreateTopic"
	KafkaService_CreateTopicDirect_FullMethodName         = "/idp.kafka.v1.KafkaService/CreateTopicDirect"
	KafkaService_GetTopic_FullMethodName                  = "/idp.kafka.v1.KafkaService/GetTopic"
	KafkaService_ListTopics_FullMethodName                = "/idp.kafka.v1.KafkaService/ListTopics"
	KafkaService_UpdateTopic_FullMethodName               = "/idp.kafka.v1.KafkaService/UpdateTopic"
	KafkaService_DeleteTopic_FullMethodName               = "/idp.kafka.v1.KafkaService/DeleteTopic"
	KafkaService_DeleteTopicByName_FullMethodName         = "/idp.kafka.v1.KafkaService/DeleteTopicByName"
	KafkaService_ApproveTopic_FullMethodName              = "/idp.kafka.v1.KafkaService/ApproveTopic"
	KafkaService_RegisterSchema_FullMethodName            = "/idp.kafka.v1.KafkaService/RegisterSchema"
	KafkaService_GetSchema_FullMethodName                 = "/idp.kafka.v1.KafkaService/GetSchema"
	KafkaService_ListSchemas_FullMethodName               = "/idp.kafka.v1.KafkaService/ListSchemas"
	KafkaService_CheckSchemaCompatibility_FullMethodName  = "/idp.kafka.v1.KafkaService/CheckSchemaCompatibility"
	KafkaService_CreateServiceAccount_FullMethodName      = "/idp.kafka.v1.KafkaService/CreateServiceAccount"
	KafkaService_ListServiceAccounts_FullMethodName       = "/idp.kafka.v1.KafkaService/ListServiceAccounts"
	KafkaService_RevokeServiceAccount_FullMethodName      = "/idp.kafka.v1.KafkaService/RevokeServiceAccount"
	KafkaService_RequestTopicAccess_FullMethodName        = "/idp.kafka.v1.KafkaService/RequestTopicAccess"
	KafkaService_ApproveTopicAccess_FullMethodName        = "/idp.kafka.v1.KafkaService/ApproveTopicAccess"
	KafkaService_RevokeTopicAccess_FullMethodName         = "/idp.kafka.v1.KafkaService/RevokeTopicAccess"
	KafkaService_ListTopicShares_FullMethodName           = "/idp.kafka.v1.KafkaService/ListTopicShares"
	KafkaService_DiscoverTopics_FullMethodName            = "/idp.kafka.v1.KafkaService/DiscoverTopics"
	KafkaService_GetTopicMetrics_FullMethodName           = "/idp.kafka.v1.KafkaService/GetTopicMetrics"
	KafkaService_GetTopicLineage_FullMethodName           = "/idp.kafka.v1.KafkaService/GetTopicLineage"
)

// KafkaServiceClient is the client API for KafkaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KafkaServiceClient interface {
	// Cluster Management (Platform Admin)
	ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error)
	RegisterCluster(ctx context.Context, in *RegisterClusterRequest, opts ...grpc.CallOption) (*RegisterClusterResponse, error)
	ValidateCluster(ctx context.Context, in *ValidateClusterRequest, opts ...grpc.CallOption) (*ValidateClusterResponse, error)
	ValidateClusterConnection(ctx context.Context, in *ValidateClusterConnectionRequest, opts ...grpc.CallOption) (*ValidateClusterConnectionResponse, error)
	ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	DeleteCluster(ctx context.Context, in *DeleteClusterRequest, opts ...grpc.CallOption) (*DeleteClusterResponse, error)
	// Environment Mapping (Platform Admin)
	CreateEnvironmentMapping(ctx context.Context, in *CreateEnvironmentMappingRequest, opts ...grpc.CallOption) (*CreateEnvironmentMappingResponse, error)
	ListEnvironmentMappings(ctx context.Context, in *ListEnvironmentMappingsRequest, opts ...grpc.CallOption) (*ListEnvironmentMappingsResponse, error)
	DeleteEnvironmentMapping(ctx context.Context, in *DeleteEnvironmentMappingRequest, opts ...grpc.CallOption) (*DeleteEnvironmentMappingResponse, error)
	// Topic Management (Workspace Scoped)
	CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error)
	CreateTopicDirect(ctx context.Context, in *CreateTopicDirectRequest, opts ...grpc.CallOption) (*CreateTopicDirectResponse, error)
	GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error)
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*UpdateTopicResponse, error)
	DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*DeleteTopicResponse, error)
	DeleteTopicByName(ctx context.Context, in *DeleteTopicByNameRequest, opts ...grpc.CallOption) (*DeleteTopicByNameResponse, error)
	ApproveTopic(ctx context.Context, in *ApproveTopicRequest, opts ...grpc.CallOption) (*ApproveTopicResponse, error)
	// Schema Management
	RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error)
	GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	ListSchemas(ctx context.Context, in *ListSchemasRequest, opts ...grpc.CallOption) (*ListSchemasResponse, error)
	CheckSchemaCompatibility(ctx context.Context, in *CheckSchemaCompatibilityRequest, opts ...grpc.CallOption) (*CheckSchemaCompatibilityResponse, error)
	// Service Account Management
	CreateServiceAccount(ctx context.Context, in *CreateServiceAccountRequest, opts ...grpc.CallOption) (*CreateServiceAccountResponse, error)
	ListServiceAccounts(ctx context.Context, in *ListServiceAccountsRequest, opts ...grpc.CallOption) (*ListServiceAccountsResponse, error)
	RevokeServiceAccount(ctx context.Context, in *RevokeServiceAccountRequest, opts ...grpc.CallOption) (*RevokeServiceAccountResponse, error)
	// Topic Sharing
	RequestTopicAccess(ctx context.Context, in *RequestTopicAccessRequest, opts ...grpc.CallOption) (*RequestTopicAccessResponse, error)
	ApproveTopicAccess(ctx context.Context, in *ApproveTopicAccessRequest, opts ...grpc.CallOption) (*ApproveTopicAccessResponse, error)
	RevokeTopicAccess(ctx context.Context, in *RevokeTopicAccessRequest, opts ...grpc.CallOption) (*RevokeTopicAccessResponse, error)
	ListTopicShares(ctx context.Context, in *ListTopicSharesRequest, opts ...grpc.CallOption) (*ListTopicSharesResponse, error)
	// Discovery (Global Catalog)
	DiscoverTopics(ctx context.Context, in *DiscoverTopicsRequest, opts ...grpc.CallOption) (*DiscoverTopicsResponse, error)
	// Metrics & Lineage
	GetTopicMetrics(ctx context.Context, in *GetTopicMetricsRequest, opts ...grpc.CallOption) (*GetTopicMetricsResponse, error)
	GetTopicLineage(ctx context.Context, in *GetTopicLineageRequest, opts ...grpc.CallOption) (*GetTopicLineageResponse, error)
}

type kafkaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKafkaServiceClient(cc grpc.ClientConnInterface) KafkaServiceClient {
	return &kafkaServiceClient{cc}
}

func (c *kafkaServiceClient) ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProvidersResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) RegisterCluster(ctx context.Context, in *RegisterClusterRequest, opts ...grpc.CallOption) (*RegisterClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterClusterResponse)
	err := c.cc.Invoke(ctx, KafkaService_RegisterCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ValidateCluster(ctx context.Context, in *ValidateClusterRequest, opts ...grpc.CallOption) (*ValidateClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateClusterResponse)
	err := c.cc.Invoke(ctx, KafkaService_ValidateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ValidateClusterConnection(ctx context.Context, in *ValidateClusterConnectionRequest, opts ...grpc.CallOption) (*ValidateClusterConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateClusterConnectionResponse)
	err := c.cc.Invoke(ctx, KafkaService_ValidateClusterConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) DeleteCluster(ctx context.Context, in *DeleteClusterRequest, opts ...grpc.CallOption) (*DeleteClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClusterResponse)
	err := c.cc.Invoke(ctx, KafkaService_DeleteCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) CreateEnvironmentMapping(ctx context.Context, in *CreateEnvironmentMappingRequest, opts ...grpc.CallOption) (*CreateEnvironmentMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateEnvironmentMappingResponse)
	err := c.cc.Invoke(ctx, KafkaService_CreateEnvironmentMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListEnvironmentMappings(ctx context.Context, in *ListEnvironmentMappingsRequest, opts ...grpc.CallOption) (*ListEnvironmentMappingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEnvironmentMappingsResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListEnvironmentMappings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) DeleteEnvironmentMapping(ctx context.Context, in *DeleteEnvironmentMappingRequest, opts ...grpc.CallOption) (*DeleteEnvironmentMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteEnvironmentMappingResponse)
	err := c.cc.Invoke(ctx, KafkaService_DeleteEnvironmentMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTopicResponse)
	err := c.cc.Invoke(ctx, KafkaService_CreateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) CreateTopicDirect(ctx context.Context, in *CreateTopicDirectRequest, opts ...grpc.CallOption) (*CreateTopicDirectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTopicDirectResponse)
	err := c.cc.Invoke(ctx, KafkaService_CreateTopicDirect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicResponse)
	err := c.cc.Invoke(ctx, KafkaService_GetTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*UpdateTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTopicResponse)
	err := c.cc.Invoke(ctx, KafkaService_UpdateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*DeleteTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTopicResponse)
	err := c.cc.Invoke(ctx, KafkaService_DeleteTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) DeleteTopicByName(ctx context.Context, in *DeleteTopicByNameRequest, opts ...grpc.CallOption) (*DeleteTopicByNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTopicByNameResponse)
	err := c.cc.Invoke(ctx, KafkaService_DeleteTopicByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ApproveTopic(ctx context.Context, in *ApproveTopicRequest, opts ...grpc.CallOption) (*ApproveTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveTopicResponse)
	err := c.cc.Invoke(ctx, KafkaService_ApproveTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterSchemaResponse)
	err := c.cc.Invoke(ctx, KafkaService_RegisterSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, KafkaService_GetSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListSchemas(ctx context.Context, in *ListSchemasRequest, opts ...grpc.CallOption) (*ListSchemasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSchemasResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListSchemas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) CheckSchemaCompatibility(ctx context.Context, in *CheckSchemaCompatibilityRequest, opts ...grpc.CallOption) (*CheckSchemaCompatibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSchemaCompatibilityResponse)
	err := c.cc.Invoke(ctx, KafkaService_CheckSchemaCompatibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) CreateServiceAccount(ctx context.Context, in *CreateServiceAccountRequest, opts ...grpc.CallOption) (*CreateServiceAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateServiceAccountResponse)
	err := c.cc.Invoke(ctx, KafkaService_CreateServiceAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListServiceAccounts(ctx context.Context, in *ListServiceAccountsRequest, opts ...grpc.CallOption) (*ListServiceAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServiceAccountsResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListServiceAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) RevokeServiceAccount(ctx context.Context, in *RevokeServiceAccountRequest, opts ...grpc.CallOption) (*RevokeServiceAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeServiceAccountResponse)
	err := c.cc.Invoke(ctx, KafkaService_RevokeServiceAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) RequestTopicAccess(ctx context.Context, in *RequestTopicAccessRequest, opts ...grpc.CallOption) (*RequestTopicAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestTopicAccessResponse)
	err := c.cc.Invoke(ctx, KafkaService_RequestTopicAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ApproveTopicAccess(ctx context.Context, in *ApproveTopicAccessRequest, opts ...grpc.CallOption) (*ApproveTopicAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveTopicAccessResponse)
	err := c.cc.Invoke(ctx, KafkaService_ApproveTopicAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) RevokeTopicAccess(ctx context.Context, in *RevokeTopicAccessRequest, opts ...grpc.CallOption) (*RevokeTopicAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeTopicAccessResponse)
	err := c.cc.Invoke(ctx, KafkaService_RevokeTopicAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) ListTopicShares(ctx context.Context, in *ListTopicSharesRequest, opts ...grpc.CallOption) (*ListTopicSharesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicSharesResponse)
	err := c.cc.Invoke(ctx, KafkaService_ListTopicShares_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) DiscoverTopics(ctx context.Context, in *DiscoverTopicsRequest, opts ...grpc.CallOption) (*DiscoverTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DiscoverTopicsResponse)
	err := c.cc.Invoke(ctx, KafkaService_DiscoverTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) GetTopicMetrics(ctx context.Context, in *GetTopicMetricsRequest, opts ...grpc.CallOption) (*GetTopicMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicMetricsResponse)
	err := c.cc.Invoke(ctx, KafkaService_GetTopicMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaServiceClient) GetTopicLineage(ctx context.Context, in *GetTopicLineageRequest, opts ...grpc.CallOption) (*GetTopicLineageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicLineageResponse)
	err := c.cc.Invoke(ctx, KafkaService_GetTopicLineage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KafkaServiceServer is the server API for KafkaService service.
// All implementations must embed UnimplementedKafkaServiceServer
// for forward compatibility.
type KafkaServiceServer interface {
	// Cluster Management (Platform Admin)
	ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error)
	RegisterCluster(context.Context, *RegisterClusterRequest) (*RegisterClusterResponse, error)
	ValidateCluster(context.Context, *ValidateClusterRequest) (*ValidateClusterResponse, error)
	ValidateClusterConnection(context.Context, *ValidateClusterConnectionRequest) (*ValidateClusterConnectionResponse, error)
	ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error)
	DeleteCluster(context.Context, *DeleteClusterRequest) (*DeleteClusterResponse, error)
	// Environment Mapping (Platform Admin)
	CreateEnvironmentMapping(context.Context, *CreateEnvironmentMappingRequest) (*CreateEnvironmentMappingResponse, error)
	ListEnvironmentMappings(context.Context, *ListEnvironmentMappingsRequest) (*ListEnvironmentMappingsResponse, error)
	DeleteEnvironmentMapping(context.Context, *DeleteEnvironmentMappingRequest) (*DeleteEnvironmentMappingResponse, error)
	// Topic Management (Workspace Scoped)
	CreateTopic(context.Context, *CreateTopicRequest) (*CreateTopicResponse, error)
	CreateTopicDirect(context.Context, *CreateTopicDirectRequest) (*CreateTopicDirectResponse, error)
	GetTopic(context.Context, *GetTopicRequest) (*GetTopicResponse, error)
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	UpdateTopic(context.Context, *UpdateTopicRequest) (*UpdateTopicResponse, error)
	DeleteTopic(context.Context, *DeleteTopicRequest) (*DeleteTopicResponse, error)
	DeleteTopicByName(context.Context, *DeleteTopicByNameRequest) (*DeleteTopicByNameResponse, error)
	ApproveTopic(context.Context, *ApproveTopicRequest) (*ApproveTopicResponse, error)
	// Schema Management
	RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error)
	GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error)
	ListSchemas(context.Context, *ListSchemasRequest) (*ListSchemasResponse, error)
	CheckSchemaCompatibility(context.Context, *CheckSchemaCompatibilityRequest) (*CheckSchemaCompatibilityResponse, error)
	// Service Account Management
	CreateServiceAccount(context.Context, *CreateServiceAccountRequest) (*CreateServiceAccountResponse, error)
	ListServiceAccounts(context.Context, *ListServiceAccountsRequest) (*ListServiceAccountsResponse, error)
	RevokeServiceAccount(context.Context, *RevokeServiceAccountRequest) (*RevokeServiceAccountResponse, error)
	// Topic Sharing
	RequestTopicAccess(context.Context, *RequestTopicAccessRequest) (*RequestTopicAccessResponse, error)
	ApproveTopicAccess(context.Context, *ApproveTopicAccessRequest) (*ApproveTopicAccessResponse, error)
	RevokeTopicAccess(context.Context, *RevokeTopicAccessRequest) (*RevokeTopicAccessResponse, error)
	ListTopicShares(context.Context, *ListTopicSharesRequest) (*ListTopicSharesResponse, error)
	// Discovery (Global Catalog)
	DiscoverTopics(context.Context, *DiscoverTopicsRequest) (*DiscoverTopicsResponse, error)
	// Metrics & Lineage
	GetTopicMetrics(context.Context, *GetTopicMetricsRequest) (*GetTopicMetricsResponse, error)
	GetTopicLineage(context.Context, *GetTopicLineageRequest) (*GetTopicLineageResponse, error)
	mustEmbedUnimplementedKafkaServiceServer()
}

// UnimplementedKafkaServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKafkaServiceServer struct{}

func (UnimplementedKafkaServiceServer) ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProviders not implemented")
}
func (UnimplementedKafkaServiceServer) RegisterCluster(context.Context, *RegisterClusterRequest) (*RegisterClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterCluster not implemented")
}
func (UnimplementedKafkaServiceServer) ValidateCluster(context.Context, *ValidateClusterRequest) (*ValidateClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateCluster not implemented")
}
func (UnimplementedKafkaServiceServer) ValidateClusterConnection(context.Context, *ValidateClusterConnectionRequest) (*ValidateClusterConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateClusterConnection not implemented")
}
func (UnimplementedKafkaServiceServer) ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusters not implemented")
}
func (UnimplementedKafkaServiceServer) DeleteCluster(context.Context, *DeleteClusterRequest) (*DeleteClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (UnimplementedKafkaServiceServer) CreateEnvironmentMapping(context.Context, *CreateEnvironmentMappingRequest) (*CreateEnvironmentMappingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEnvironmentMapping not implemented")
}
func (UnimplementedKafkaServiceServer) ListEnvironmentMappings(context.Context, *ListEnvironmentMappingsRequest) (*ListEnvironmentMappingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEnvironmentMappings not implemented")
}
func (UnimplementedKafkaServiceServer) DeleteEnvironmentMapping(context.Context, *DeleteEnvironmentMappingRequest) (*DeleteEnvironmentMappingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteEnvironmentMapping not implemented")
}
func (UnimplementedKafkaServiceServer) CreateTopic(context.Context, *CreateTopicRequest) (*CreateTopicResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTopic not implemented")
}
func (UnimplementedKafkaServiceServer) CreateTopicDirect(context.Context, *CreateTopicDirectRequest) (*CreateTopicDirectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTopicDirect not implemented")
}
func (UnimplementedKafkaServiceServer) GetTopic(context.Context, *GetTopicRequest) (*GetTopicResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopic not implemented")
}
func (UnimplementedKafkaServiceServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedKafkaServiceServer) UpdateTopic(context.Context, *UpdateTopicRequest) (*UpdateTopicResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTopic not implemented")
}
func (UnimplementedKafkaServiceServer) DeleteTopic(context.Context, *DeleteTopicRequest) (*DeleteTopicResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTopic not implemented")
}
func (UnimplementedKafkaServiceServer) DeleteTopicByName(context.Context, *DeleteTopicByNameRequest) (*DeleteTopicByNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTopicByName not implemented")
}
func (UnimplementedKafkaServiceServer) ApproveTopic(context.Context, *ApproveTopicRequest) (*ApproveTopicResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveTopic not implemented")
}
func (UnimplementedKafkaServiceServer) RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterSchema not implemented")
}
func (UnimplementedKafkaServiceServer) GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedKafkaServiceServer) ListSchemas(context.Context, *ListSchemasRequest) (*ListSchemasResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSchemas not implemented")
}
func (UnimplementedKafkaServiceServer) CheckSchemaCompatibility(context.Context, *CheckSchemaCompatibilityRequest) (*CheckSchemaCompatibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckSchemaCompatibility not implemented")
}
func (UnimplementedKafkaServiceServer) CreateServiceAccount(context.Context, *CreateServiceAccountRequest) (*CreateServiceAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateServiceAccount not implemented")
}
func (UnimplementedKafkaServiceServer) ListServiceAccounts(context.Context, *ListServiceAccountsRequest) (*ListServiceAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServiceAccounts not implemented")
}
func (UnimplementedKafkaServiceServer) RevokeServiceAccount(context.Context, *RevokeServiceAccountRequest) (*RevokeServiceAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeServiceAccount not implemented")
}
func (UnimplementedKafkaServiceServer) RequestTopicAccess(context.Context, *RequestTopicAccessRequest) (*RequestTopicAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestTopicAccess not implemented")
}
func (UnimplementedKafkaServiceServer) ApproveTopicAccess(context.Context, *ApproveTopicAccessRequest) (*ApproveTopicAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveTopicAccess not implemented")
}
func (UnimplementedKafkaServiceServer) RevokeTopicAccess(context.Context, *RevokeTopicAccessRequest) (*RevokeTopicAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeTopicAccess not implemented")
}
func (UnimplementedKafkaServiceServer) ListTopicShares(context.Context, *ListTopicSharesRequest) (*ListTopicSharesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTopicShares not implemented")
}
func (UnimplementedKafkaServiceServer) DiscoverTopics(context.Context, *DiscoverTopicsRequest) (*DiscoverTopicsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DiscoverTopics not implemented")
}
func (UnimplementedKafkaServiceServer) GetTopicMetrics(context.Context, *GetTopicMetricsRequest) (*GetTopicMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopicMetrics not implemented")
}
func (UnimplementedKafkaServiceServer) GetTopicLineage(context.Context, *GetTopicLineageRequest) (*GetTopicLineageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopicLineage not implemented")
}
func (UnimplementedKafkaServiceServer) mustEmbedUnimplementedKafkaServiceServer() {}
func (UnimplementedKafkaServiceServer) testEmbeddedByValue()                      {}

// UnsafeKafkaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KafkaServiceServer will
// result in compilation errors.
type UnsafeKafkaServiceServer interface {
	mustEmbedUnimplementedKafkaServiceServer()
}

func RegisterKafkaServiceServer(s grpc.ServiceRegistrar, srv KafkaServiceServer) {
	// If the following call panics, it indicates UnimplementedKafkaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KafkaService_ServiceDesc, srv)
}

func _KafkaService_ListProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListProviders(ctx, req.(*ListProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_RegisterCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).RegisterCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_RegisterCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).RegisterCluster(ctx, req.(*RegisterClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ValidateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ValidateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ValidateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ValidateCluster(ctx, req.(*ValidateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ValidateClusterConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateClusterConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ValidateClusterConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ValidateClusterConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ValidateClusterConnection(ctx, req.(*ValidateClusterConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListClusters(ctx, req.(*ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_DeleteCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).DeleteCluster(ctx, req.(*DeleteClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_CreateEnvironmentMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEnvironmentMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).CreateEnvironmentMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_CreateEnvironmentMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).CreateEnvironmentMapping(ctx, req.(*CreateEnvironmentMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListEnvironmentMappings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEnvironmentMappingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListEnvironmentMappings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListEnvironmentMappings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListEnvironmentMappings(ctx, req.(*ListEnvironmentMappingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_DeleteEnvironmentMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEnvironmentMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).DeleteEnvironmentMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_DeleteEnvironmentMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).DeleteEnvironmentMapping(ctx, req.(*DeleteEnvironmentMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_CreateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).CreateTopic(ctx, req.(*CreateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_CreateTopicDirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicDirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).CreateTopicDirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_CreateTopicDirect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).CreateTopicDirect(ctx, req.(*CreateTopicDirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).GetTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_GetTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).GetTopic(ctx, req.(*GetTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).UpdateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_UpdateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).UpdateTopic(ctx, req.(*UpdateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).DeleteTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_DeleteTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).DeleteTopic(ctx, req.(*DeleteTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_DeleteTopicByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTopicByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).DeleteTopicByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_DeleteTopicByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).DeleteTopicByName(ctx, req.(*DeleteTopicByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ApproveTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ApproveTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ApproveTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ApproveTopic(ctx, req.(*ApproveTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_RegisterSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).RegisterSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_RegisterSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).RegisterSchema(ctx, req.(*RegisterSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_GetSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).GetSchema(ctx, req.(*GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListSchemas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListSchemas(ctx, req.(*ListSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_CheckSchemaCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSchemaCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).CheckSchemaCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_CheckSchemaCompatibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).CheckSchemaCompatibility(ctx, req.(*CheckSchemaCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_CreateServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).CreateServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_CreateServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).CreateServiceAccount(ctx, req.(*CreateServiceAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListServiceAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServiceAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListServiceAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListServiceAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListServiceAccounts(ctx, req.(*ListServiceAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_RevokeServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeServiceAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).RevokeServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_RevokeServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).RevokeServiceAccount(ctx, req.(*RevokeServiceAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_RequestTopicAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTopicAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).RequestTopicAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_RequestTopicAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).RequestTopicAccess(ctx, req.(*RequestTopicAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ApproveTopicAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveTopicAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ApproveTopicAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ApproveTopicAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ApproveTopicAccess(ctx, req.(*ApproveTopicAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_RevokeTopicAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTopicAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).RevokeTopicAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_RevokeTopicAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).RevokeTopicAccess(ctx, req.(*RevokeTopicAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_ListTopicShares_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).ListTopicShares(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_ListTopicShares_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).ListTopicShares(ctx, req.(*ListTopicSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_DiscoverTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).DiscoverTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_DiscoverTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).DiscoverTopics(ctx, req.(*DiscoverTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_GetTopicMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).GetTopicMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_GetTopicMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).GetTopicMetrics(ctx, req.(*GetTopicMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaService_GetTopicLineage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicLineageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaServiceServer).GetTopicLineage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KafkaService_GetTopicLineage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaServiceServer).GetTopicLineage(ctx, req.(*GetTopicLineageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KafkaService_ServiceDesc is the grpc.ServiceDesc for KafkaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KafkaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idp.kafka.v1.KafkaService",
	HandlerType: (*KafkaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProviders",
			Handler:    _KafkaService_ListProviders_Handler,
		},
		{
			MethodName: "RegisterCluster",
			Handler:    _KafkaService_RegisterCluster_Handler,
		},
		{
			MethodName: "ValidateCluster",
			Handler:    _KafkaService_ValidateCluster_Handler,
		},
		{
			MethodName: "ValidateClusterConnection",
			Handler:    _KafkaService_ValidateClusterConnection_Handler,
		},
		{
			MethodName: "ListClusters",
			Handler:    _KafkaService_ListClusters_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _KafkaService_DeleteCluster_Handler,
		},
		{
			MethodName: "CreateEnvironmentMapping",
			Handler:    _KafkaService_CreateEnvironmentMapping_Handler,
		},
		{
			MethodName: "ListEnvironmentMappings",
			Handler:    _KafkaService_ListEnvironmentMappings_Handler,
		},
		{
			MethodName: "DeleteEnvironmentMapping",
			Handler:    _KafkaService_DeleteEnvironmentMapping_Handler,
		},
		{
			MethodName: "CreateTopic",
			Handler:    _KafkaService_CreateTopic_Handler,
		},
		{
			MethodName: "CreateTopicDirect",
			Handler:    _KafkaService_CreateTopicDirect_Handler,
		},
		{
			MethodName: "GetTopic",
			Handler:    _KafkaService_GetTopic_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _KafkaService_ListTopics_Handler,
		},
		{
			MethodName: "UpdateTopic",
			Handler:    _KafkaService_UpdateTopic_Handler,
		},
		{
			MethodName: "DeleteTopic",
			Handler:    _KafkaService_DeleteTopic_Handler,
		},
		{
			MethodName: "DeleteTopicByName",
			Handler:    _KafkaService_DeleteTopicByName_Handler,
		},
		{
			MethodName: "ApproveTopic",
			Handler:    _KafkaService_ApproveTopic_Handler,
		},
		{
			MethodName: "RegisterSchema",
			Handler:    _KafkaService_RegisterSchema_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _KafkaService_GetSchema_Handler,
		},
		{
			MethodName: "ListSchemas",
			Handler:    _KafkaService_ListSchemas_Handler,
		},
		{
			MethodName: "CheckSchemaCompatibility",
			Handler:    _KafkaService_CheckSchemaCompatibility_Handler,
		},
		{
			MethodName: "CreateServiceAccount",
			Handler:    _KafkaService_CreateServiceAccount_Handler,
		},
		{
			MethodName: "ListServiceAccounts",
			Handler:    _KafkaService_ListServiceAccounts_Handler,
		},
		{
			MethodName: "RevokeServiceAccount",
			Handler:    _KafkaService_RevokeServiceAccount_Handler,
		},
		{
			MethodName: "RequestTopicAccess",
			Handler:    _KafkaService_RequestTopicAccess_Handler,
		},
		{
			MethodName: "ApproveTopicAccess",
			Handler:    _KafkaService_ApproveTopicAccess_Handler,
		},
		{
			MethodName: "RevokeTopicAccess",
			Handler:    _KafkaService_RevokeTopicAccess_Handler,
		},
		{
			MethodName: "ListTopicShares",
			Handler:    _KafkaService_ListTopicShares_Handler,
		},
		{
			MethodName: "DiscoverTopics",
			Handler:    _KafkaService_DiscoverTopics_Handler,
		},
		{
			MethodName: "GetTopicMetrics",
			Handler:    _KafkaService_GetTopicMetrics_Handler,
		},
		{
			MethodName: "GetTopicLineage",
			Handler:    _KafkaService_GetTopicLineage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "idp/kafka/v1/kafka.proto",
}
